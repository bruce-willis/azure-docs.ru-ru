---
title: Начало работы с запросами в службе Azure Log Analytics | Документация Майкрософт
description: В этой статье содержится руководство по написанию запросов в Log Analytics.
services: log-analytics
documentationcenter: ''
author: bwren
manager: carmonm
editor: ''
ms.assetid: ''
ms.service: log-analytics
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: conceptual
ms.date: 08/06/2018
ms.author: bwren
ms.component: na
ms.openlocfilehash: 71d50a55d9c584b61a1412bb03a03ad99f1bb96c
ms.sourcegitcommit: 4de6a8671c445fae31f760385710f17d504228f8
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/08/2018
ms.locfileid: "39632916"
---
# <a name="get-started-with-queries-in-log-analytics"></a>Начало работы с запросами в Log Analytics


> [!NOTE]
> Прежде чем приступать к этому руководству, необходимо ознакомиться со статьей [Начало работы с порталом аналитики](get-started-analytics-portal.md).


В этом руководстве рассматривается написание запросов в Azure Log Analytics. Вы научитесь:

- понимать структуру запросов;
- сортировать результаты запроса;
- фильтровать результаты запроса;
- указывать диапазон времени;
- выбирать поля для включения в результаты;
- определять и использовать настраиваемые поля;
- вычислять и группировать результаты.


## <a name="writing-a-new-query"></a>Создание запроса
Запросы могут начинаться с имени таблицы или команды *search*. Начните с имени таблицы, так как это определит четкую область запроса и повысит как производительность запроса, так и релевантность результатов.

> [!NOTE]
> Язык запросов Azure Log Analytics учитывает регистр ввода. Ключевые слова языка обычно пишутся строчными буквами. При использовании имен таблиц или столбцов в запросе обязательно используйте правильный регистр, как показано в области схемы.

### <a name="table-based-queries"></a>Запросы на основе таблиц
Azure Log Analytics упорядочивает данные в таблицы, каждая из которых состоит из нескольких столбцов. На портале аналитики в области схемы отображаются все таблицы и столбцы. Определите интересующую вас таблицу, а затем взгляните на часть данных:

```OQL
SecurityEvent
| take 10
```

Запрос, показанный выше, возвращает 10 результатов из таблицы *SecurityEvent* в произвольном порядке. Это очень распространенный способ взглянуть на таблицу и понять ее структуру и содержимое. Давайте рассмотрим структуру запроса:

* Запрос начинается с имени таблицы *SecurityEvent* — эта часть определяет область запроса.
* Символ вертикальной черты (|) разделяет команды, поэтому выходные данные первой команды содержатся во входных данных следующей команды. Можно добавить любое число элементов, разделенных этой чертой.
* За вертикальной чертой следует команда **take**, которая возвращает указанное количество произвольных записей из таблицы.

Мы фактически могли выполнить запрос даже без добавления `| take 10`. Такой запрос тоже действительный, но он может вернуть до 10 000 результатов.

### <a name="search-queries"></a>Поисковые запросы
Поисковые запросы менее структурированы и, как правило, более подходят для поиска записей, которые содержат указанное значение в любом из столбцов:

```OQL
search in (SecurityEvent) "Cryptographic"
| take 10
```

Этот поисковый запрос выполняет в таблице *SecurityEvent* поиск записей, содержащих фразу "Cryptographic". Из этих записей будут возвращены и показаны 10. Если опустить часть `in (SecurityEvent)` и просто запустить `search "Cryptographic"`, поиск пройдет по *всем* таблицам. Это будет дольше и менее эффективно.

> [!NOTE]
> По умолчанию установлен диапазон времени _за последние 24 часа_. Чтобы использовать другой диапазон, используйте инструмент выбора времени (расположен рядом с кнопкой *Далее*) или добавьте в свой запрос явный фильтр диапазона времени.

## <a name="sort-and-top"></a>Операторы sort и top
Хотя команда **take** и полезна для получения нескольких записей, но результаты выбираются и отображаются в произвольном порядке. Чтобы получить упорядоченное представление, можно выполнить **сортировку** по предпочтительному столбцу:

```
SecurityEvent   
| sort by TimeGenerated desc
```

Такой запрос может вернуть слишком много результатов и занять некоторое время. Приведенный выше запрос сортирует *всю* таблицу SecurityEvent по столбцу TimeGenerated. Портал аналитики ограничивает отображение для вывода только 10 000 записей. Такой подход, конечно же, не оптимален.

Лучшим способом получить только последние 10 записей является использование оператора **top**, который сортирует таблицу целиком на стороне сервера, а затем возвращает первые записи:

```OQL
SecurityEvent
| top 10 by TimeGenerated
```

Порядок сортировки по убыванию используется по умолчанию, поэтому мы обычно опускаем аргумент **desc**. Результат будет выглядеть следующим образом:

![Первые 10](media/get-started-queries/top10.png)


## <a name="where-filtering-on-a-condition"></a>Оператор where: фильтрация по условию
Фильтры, как очевидно из названия, фильтруют данные по указанному условию. Это самый распространенный способ ограничения результатов запроса для получения соответствующей информации.

Чтобы добавить фильтр к запросу, используйте оператор **where**, за которым следует одно или несколько условий. Например, следующий запрос возвращает только записи *SecurityEvent*, где _Level_ равняется _8_:

```OQL
SecurityEvent
| where Level == 8
```

При написании условий фильтра вы можете использовать следующие выражения:

| Expression | ОПИСАНИЕ | Пример |
|:---|:---|:---|
| == | Проверка на равенство<br>(с учетом регистра) | `Level == 8` |
| =~ | Проверка на равенство<br>(без учета регистра) | `EventSourceName =~ "microsoft-windows-security-auditing"` |
| !=, <> | Проверка на неравенство<br>(оба выражения идентичны) | `Level != 4` |
| *and*, *or* | Требуется между условиями| `Level == 16 or CommandLine != ""` |

Чтобы отфильтровать по нескольким условиям, можно использовать оператор **and**:

```OQL
SecurityEvent
| where Level == 8 and EventID == 4672
```

Для этого также можно включить несколько элементов **where**, разделенных вертикальной чертой:

```OQL
SecurityEvent
| where Level == 8 
| where EventID == 4672
```
    
> [!NOTE]
> Значения могут иметь разные типы, поэтому может потребоваться привести их в правильный тип для выполнения сравнения. Например, столбец *Level* таблицы SecurityEvent имеет строчный тип, поэтому необходимо привести его в числовой тип, например *int* или *long*, прежде чем вы сможете использовать его с числовыми операторами: `SecurityEvent | where toint(Level) >= 10`

## <a name="specify-a-time-range"></a>Указание диапазона времени

### <a name="time-picker"></a>Средство выбора времени
В левом верхнем углу находится элемент выбора времени, указывающий, что мы запрашиваем только записи за последние 24 часа. Этот диапазон времени по умолчанию применяется ко всем запросам. Чтобы получить только записи за последний час, выберите _последний час_ и повторно запустите запрос.

![Средство выбора времени](media/get-started-queries/timepicker.png)


### <a name="time-filter-in-query"></a>Фильтр времени в запросе
Вы также можете определить ваш собственный диапазон времени, добавив фильтр времени к запросу. Лучше всего поместить фильтр времени сразу после имени таблицы: 

```OQL
SecurityEvent
| where TimeGenerated > ago(30m) 
| where toint(Level) >= 10
```

Указанный фильтр времени `ago(30m)` означает "30 минут назад", поэтому этот запрос возвращает только записи за последние 30 минут. Другие единицы времени включают в себя дни (2d), минуты (25m) и секунды (10s).


## <a name="project-and-extend-select-and-compute-columns"></a>Операторы project и extend. Выбор и вычисление столбцов
Используйте оператор **project**, чтобы выбрать конкретные столбцы, которые нужно включить в результаты:

```OQL
SecurityEvent 
| top 10 by TimeGenerated 
| project TimeGenerated, Computer, Activity
```

Предыдущий пример создает такие выходные данные:

![Результаты использования project в Log Analytics](media/get-started-queries/project.png)

С помощью **project** также можно переименовать столбцы и определить новые. В примере ниже project используется для выполнения следующих действий:

* Выбор только исходных столбцов *Computer* и *TimeGenerated*.
* Переименование столбца *Activity* в *EventDetails*.
* Создание столбца *EventCode*. Функция **substring()** используется для получения только первых четырех символов из поля Activity.


```OQL
SecurityEvent
| top 10 by TimeGenerated 
| project Computer, TimeGenerated, EventDetails=Activity, EventCode=substring(Activity, 0, 4)
```

**extend** отслеживает все исходные столбцы в результирующем наборе, а также определяет дополнительные. В следующем запросе **extend** используется для добавления столбца *localtime*, содержащего локализованное значение TimeGenerated.

```OQL
SecurityEvent
| top 10 by TimeGenerated
| extend localtime = TimeGenerated-8h
```

## <a name="summarize-aggregate-groups-of-rows"></a>Оператор summarize. Агрегирование групп строк
С помощью оператора **summarize** можно определить группы записей в соответствии с одним или несколькими столбцами и применить к ним статистические вычисления. Поэтому с **summarize** чаще всего применяется функция *count*, которая возвращает число результатов в каждой группе.

Следующий запрос проверяет все записи в таблице *Perf* за последний час, группирует их по столбцу *ObjectName* и подсчитывает количество записей в каждой группе: 
```OQL
Perf
| where TimeGenerated > ago(1h)
| summarize count() by ObjectName
```

Иногда имеет смысл определить группы по нескольким измерениям. Каждое уникальное сочетание этих значений определяет отдельную группу:

```OQL
Perf
| where TimeGenerated > ago(1h)
| summarize count() by ObjectName, CounterName
```

Другое распространенное использование — выполнять математические или статистические вычисления в каждой группе. Например, следующий фрагмент вычисляет среднее значение *CounterValue* для каждого компьютера:

```OQL
Perf
| where TimeGenerated > ago(1h)
| summarize avg(CounterValue) by Computer
```

К сожалению, результаты этого запроса бессмысленны, так как мы смешали разные счетчики производительности. Чтобы это имело смысл, следует рассчитывать среднее значение отдельно для каждого сочетания *CounterName* и *Computer*:

```OQL
Perf
| where TimeGenerated > ago(1h)
| summarize avg(CounterValue) by Computer, CounterName
```

### <a name="summarize-by-a-time-column"></a>Суммирование по столбцу времени
Результаты также можно группировать по столбцу времени или другому непрерывному значению. В результате простого суммирования `by TimeGenerated` будут созданы группы для каждой миллисекунды за определенный период времени, так как речь идет об уникальных значениях. 

Чтобы создать группы на основании непрерывных значений, рекомендуется разбить диапазон на управляемые единицы с помощью **bin**. Следующий запрос анализирует записи *Perf* с данными об измерении свободной памяти (*доступная память в МБ*) на указанном компьютере. Вычисляется среднее значение для каждого периода в 1 час за последние 2 дня:

```OQL
Perf 
| where TimeGenerated > ago(2d)
| where Computer == "ContosoAzADDS2" 
| where CounterName == "Available MBytes" 
| summarize count() by bin(TimeGenerated, 1h)
```

Чтобы сделать выходные данные более понятными, выберите отображение в виде диаграммы времени, показывающую объем доступной памяти с течением времени:

![Память Log Analytics с течением времени](media/get-started-queries/chart.png)



## <a name="next-steps"></a>Дополнительная информация

- [Дополнительные сведения о написании запросов поиска](search-queries.md)