---
title: Справочные материалы по типам триггеров и действий в Azure Logic Apps | Документация Майкрософт
description: Изучите типы триггеров и действий в Azure Logic Apps, как описано в схеме языка определения рабочего процесса
services: logic-apps
ms.service: logic-apps
author: ecfan
ms.author: estfan
manager: jeconnoc
ms.topic: reference
ms.date: 06/22/2018
ms.reviewer: klam, LADocs
ms.suite: integration
ms.openlocfilehash: 427964a6651dd4ab71d0029f89e40afdd34d162a
ms.sourcegitcommit: e3d5de6d784eb6a8268bd6d51f10b265e0619e47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/01/2018
ms.locfileid: "39390710"
---
# <a name="trigger-and-action-types-reference-for-workflow-definition-language-in-azure-logic-apps"></a>Справочные материалы по типам триггеров и действий для языка определения рабочего процесса в Azure Logic Apps

В [Azure Logic Apps](../logic-apps/logic-apps-overview.md) все рабочие процессы приложений логики запускаются с помощью триггеров, за которыми следуют действия. В этой статье описываются типы триггеров и действий, которые можно использовать при создании приложений логики для автоматизации задач, процессов и рабочих процессов. Рабочие процессы приложений логики можно создавать с помощью Конструктора Logic Apps визуально или, создавая базовые определения рабочих процессов, с помощью [языка определения рабочего процесса](../logic-apps/logic-apps-workflow-definition-language.md). Приложения логики можно создавать на портале Azure или в Visual Studio. Базовое определение для всего рабочего процесса, включая триггеры и действия, использует Javascript Object Notation (JSON).

<a name="triggers-overview"></a>

## <a name="triggers-overview"></a>Общие сведения о триггерах

Все приложения логики запускаются триггером, который определяет вызовы, создающие и запускающие рабочий процесс приложения логики. Ниже приведены общие категории триггеров.

* *Опрашивающий* триггер проверяет конечную точку службы через равные промежутки времени.

* *Извещающий* триггер создает подписку на конечную точку и предоставляет *URL-адрес обратного вызова*, чтобы конечная точка могла уведомлять триггер, когда происходит указанное событие или стали доступны данные. Затем триггер ожидает ответа конечной точки, прежде чем сработать. 

Триггеры имеют следующие основные элементы, хотя некоторые из них являются необязательными.  
  
```json
"<trigger-name>": {
   "type": "<trigger-type>",
   "inputs": { "<trigger-inputs>" },
   "recurrence": { 
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "conditions": [ "<array-with-conditions>" ],
   "runtimeConfiguration": { "<runtime-config-options>" },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
},
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*trigger-name*> | Строка | Имя триггера | 
| <*trigger-type*> | Строка | Тип триггера, например Http или ApiConnection | 
| <*trigger-inputs*> | Объект JSON | Входные данные, определяющие режим работы триггера | 
| <*time-unit*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" | 
| <*number-of-time-units*> | Целое число  | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*array-with-conditions*> | Массив, | Массив, содержащий одно или несколько [условий](#trigger-conditions), которые определяют необходимость выполнения рабочего процесса | 
| <*runtime-config-options*> | Объект JSON | Можно изменить поведение триггера во время выполнения, задав свойства `runtimeConfiguration`. Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options). | 
| <*splitOn-expression*> | Строка | Для триггеров, возвращающих массив, можно указать выражение для обработки, которое [разделяет или *выполняет по отдельности*](#split-on-debatch) элементы массива на нескольких экземплярах рабочего процесса. | 
| <*operation-option*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

## <a name="trigger-types-list"></a>Список типов триггеров

Каждый тип триггера имеет свой интерфейс и свои входные данные, которые определяют его поведение. 

### <a name="built-in-triggers"></a>Встроенные триггеры

| Тип триггера | ОПИСАНИЕ | 
|--------------|-------------| 
| [**HTTP**](#http-trigger) | Проверяет или *опрашивает* любую конечную точку. Конечная точка должна соответствовать определенному условию триггера, используя шаблон асинхронных операций 202 или возвращая массив. | 
| [**HTTPWebhook**](#http-webhook-trigger) | Создает вызываемую конечную точку для приложения логики, но также вызывает указанный URL-адрес для регистрации или отмены регистрации. |
| [**Recurrence**](#recurrence-trigger) | Активируется на основе определенного расписания. Можно задать дату и время в будущем для срабатывания триггера. На основе частоты можно также указать время и дни запуска рабочего процесса. | 
| [**Request**](#request-trigger)  | Создает вызываемую конечную точку для приложения логики, также называется "ручным" триггером. Например, ознакомьтесь со статьей [Вызовы, срабатывания триггеров и создание вложенных рабочих процессов в приложениях логики](../logic-apps/logic-apps-http-endpoint.md). | 
||| 

### <a name="managed-api-triggers"></a>Управляемые триггеры API

| Тип триггера | ОПИСАНИЕ | 
|--------------|-------------| 
| [**ApiConnection**](#apiconnection-trigger) | Проверяет или *опрашивает* конечную точку с помощью [управляемых Майкрософт интерфейсов API](../connectors/apis-list.md). | 
| [**ApiConnectionWebhook**](#apiconnectionwebhook-trigger) | Создает вызываемую конечную точку для приложения логики, вызывая [управляемые Майкрософт интерфейсы API](../connectors/apis-list.md), для подписки или отмены подписки. | 
||| 

## <a name="triggers---detailed-reference"></a>Триггеры. Подробная справочная информация

<a name="apiconnection-trigger"></a>

### <a name="apiconnection-trigger"></a>Триггер APIConnection  

Этот триггер проверяет или *опрашивает* конечную точку с помощью [управляемых Майкрософт интерфейсов API](../connectors/apis-list.md), поэтому параметры для этого триггера могут отличаться в зависимости от конечной точки. Многие разделы в этом определении триггера являются необязательными. Режим работы триггера зависит от того, включены ли разделы.

```json
"<APIConnection_trigger_name>": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<connection-name>']['connectionId']"
         }
      },
      "method": "<method-type>",
      "path": "/<api-operation>",
      "retryPolicy": { "<retry-behavior>" },
      "queries": { "<query-parameters>" }
   },
   "recurrence": { 
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*APIConnection_trigger_name*> | Строка | Имя триггера | 
| <*имя_соединения*> | Строка | Имя подключения к управляемому API, который используется рабочим процессом | 
| <*method-type*> | Строка | Метод HTTP для обмена данными с управляемым API: GET, PUT, POST, PATCH или DELETE | 
| <*api-operation*> | Строка | Операция API для вызова | 
| <*time-unit*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" | 
| <*number-of-time-units*> | Целое число  | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*retry-behavior*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*query-parameters*> | Объект JSON | Все параметры запроса для включения с помощью вызова API. Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*max-runs*> | Целое число  | По умолчанию экземпляры рабочих процессов приложения логики запускаются одновременно или параллельно до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-queue*> | Целое число  | Когда приложение логики уже выполняет максимальное количество экземпляров, которое можно изменить на основе свойства `runtimeConfiguration.concurrency.runs`, все новые запуски помещаются в эту очередь до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*splitOn-expression*> | Строка | Для триггеров, возвращающих массивы, это выражение ссылается на массив, который необходимо использовать, чтобы вы могли создать и запустить экземпляр рабочего процесса для каждого элемента массива, а не использовали цикл Foreach. <p>Например, следующее выражение представляет элемент массива, возвращенный внутри тела триггера: `@triggerbody()?['value']` |
| <*operation-option*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
||||

*Outputs*
 
| Элемент | type | ОПИСАНИЕ |
|---------|------|-------------| 
| Заголовки | Объект JSON | Заголовки из ответа | 
| текст | Объект JSON | Текст из ответа | 
|||| 

*Пример*

Следующее определение триггера каждый день проверяет электронную почту в папке "Входящие" для учетной записи Office 365 Outlook. 

```json
"When_a_new_email_arrives": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }     
      },
      "method": "get",
      "path": "/Mail/OnNewEmail",
      "queries": {
          "fetchOnlyWithAttachment": false,
          "folderPath": "Inbox",
          "importance": "Any",
          "includeAttachments": false
      }
   },
   "recurrence": {
      "frequency": "Day",
      "interval": 1
   }
}
```

<a name="apiconnectionwebhook-trigger"></a>

### <a name="apiconnectionwebhook-trigger"></a>Триггер ApiConnectionWebhook

Этот триггер отправляет запрос подписке в конечную точку с помощью [управляемых Майкрософт интерфейсов API](../connectors/apis-list.md), предоставляет *URL-адрес обратного вызова*, на который конечная точка может отправить ответ, и ожидает ответа конечной точки. Дополнительные сведения см. в разделе [Подписка конечной точки](#subscribe-unsubscribe).

```json
"<ApiConnectionWebhook_trigger_name>": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "body": {
          "NotificationUrl": "@{listCallbackUrl()}"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<connection-name>']['connectionId']"
         }
      },
      "retryPolicy": { "<retry-behavior>" },
      "queries": "<query-parameters>"
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-run-queue>
      }
   },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*имя_соединения*> | Строка | Имя подключения к управляемому API, который используется рабочим процессом | 
| <*body-content*> | Объект JSON | Любое содержимое сообщения для отправки на управляемый API в качестве полезных данных | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*retry-behavior*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*query-parameters*> | Объект JSON | Все параметры запроса для включения в вызов API <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*max-runs*> | Целое число  | По умолчанию экземпляры рабочих процессов приложения логики запускаются одновременно или параллельно до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-queue*> | Целое число  | Когда приложение логики уже выполняет максимальное количество экземпляров, которое можно изменить на основе свойства `runtimeConfiguration.concurrency.runs`, все новые запуски помещаются в эту очередь до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*splitOn-expression*> | Строка | Для триггеров, возвращающих массивы, это выражение ссылается на массив, который необходимо использовать, чтобы вы могли создать и запустить экземпляр рабочего процесса для каждого элемента массива, а не использовали цикл Foreach. <p>Например, следующее выражение представляет элемент массива, возвращенный внутри тела триггера: `@triggerbody()?['value']` |
| <*operation-option*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Пример*

Это определение триггера подписывается на API Office 365 Outlook, предоставляет URL-адрес обратного вызова на конечную точку API и ожидает ответа конечной точки при получении нового электронного письма.

```json
"When_a_new_email_arrives_(webhook)": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "body": {
         "NotificationUrl": "@{listCallbackUrl()}" 
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "path": "/MailSubscription/$subscriptions",
      "queries": {
          "folderPath": "Inbox",
          "hasAttachment": "Any",
          "importance": "Any"
      }
   },
   "splitOn": "@triggerBody()?['value']"
}
```

<a name="http-trigger"></a>

### <a name="http-trigger"></a>Триггер HTTP

Этот триггер проверяет или опрашивает указанную конечную точку, основываясь на определенном расписании повторов. Ответ конечной точки определяет, выполняется ли рабочий процесс.

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "<method-type>",
      "uri": "<endpoint-URL>",
      "headers": { "<header-content>" },
      "body": "<body-content>",
      "authentication": { "<authentication-method>" },
      "retryPolicy": { "<retry-behavior>" },
      "queries": "<query-parameters>"
   },
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*method-type*> | Строка | Метод HTTP для опроса указанной конечной точки: GET, PUT, POST, PATCH или DELETE | 
| <*endpoint-URL*> | Строка | URL-адрес HTTP или HTTPS конечной точки для опроса <p>Максимальный размер строки: 2 КБ. | 
| <*time-unit*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" | 
| <*number-of-time-units*> | Целое число  | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*header-content*> | Объект JSON | Заголовки для отправки с запросом <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| <*body-content*> | Строка | Содержимое сообщения для отправки в качестве полезных данных с запросом | 
| <*authentication-method*> | Объект JSON | Метод, используемый запросом для проверки подлинности. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). Помимо планировщика поддерживается свойство `authority`. По умолчанию его значение равно `https://login.windows.net`, если не указано другое. Также можно использовать другое значение, например `https://login.windows\-ppe.net`. |
| <*retry-behavior*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). |  
 <*query-parameters*> | Объект JSON | Все параметры запроса для включения с помощью запроса <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к запросу. | 
| <*max-runs*> | Целое число  | По умолчанию экземпляры рабочих процессов приложения логики запускаются одновременно или параллельно до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-queue*> | Целое число  | Когда приложение логики уже выполняет максимальное количество экземпляров, которое можно изменить на основе свойства `runtimeConfiguration.concurrency.runs`, все новые запуски помещаются в эту очередь до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*operation-option*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Outputs*

| Элемент | type | ОПИСАНИЕ |
|---------|------|-------------| 
| Заголовки | Объект JSON | Заголовки из ответа | 
| текст | Объект JSON | Текст из ответа | 
|||| 

*Требования для входящих запросов*

Для качественной работы с приложением логики конечная точка должна соответствовать определенному шаблону или условию триггера и распознавать следующие свойства.  
  
| Ответ | Обязательно | ОПИСАНИЕ | 
|----------|----------|-------------|  
| Код состояния | Yes | Код состояния "200 OK" инициирует запуск. Другие коды состояния — нет. | 
| Заголовок retry-after | Нет  | Количество секунд перед повторным опросом конечной точки приложением логики. | 
| Заголовок Location | Нет  | URL-адрес для вызова во время следующего интервала опроса. Если не указан, используется исходный URL-адрес. | 
|||| 

*Пример поведения для различных запросов*

| Код состояния | Повтор через | Поведение | 
|-------------|-------------|----------|
| 200 | {нет} | Выполняется рабочий процесс, затем после определенного количества повторений снова проверяется, не добавились ли данные. | 
| 200 | 10 с | Выполняется рабочий процесс, затем через 10 секунд снова проверяется, не добавились ли данные. |  
| 202 | 60 секунд | Рабочий процесс не запускается. Следующая попытка происходит через одну минуту с учетом определенного повторения. Если определенное повторение составляет менее минуты, то приоритет имеет заголовок retry-after. В противном случае используется определенное повторение. | 
| 400 | {нет} | Недопустимый запрос, рабочий процесс не запускается. Если параметр `retryPolicy` не задан, то используется политика по умолчанию. После достижения количества попыток триггер снова проверяет наличие данных после определенного числа повторений. | 
| 500 | {нет}| Ошибка сервера, рабочий процесс не запускается. Если параметр `retryPolicy` не задан, то используется политика по умолчанию. После достижения количества попыток триггер снова проверяет наличие данных после определенного числа повторений. | 
|||| 

<a name="http-webhook-trigger"></a>

### <a name="httpwebhook-trigger"></a>Триггер httpWebhook  

Этот триггер делает приложение логики вызываемым, создавая конечную точку, которая может зарегистрировать подписку путем вызова URL-адреса указанной конечной точки. При создании этого триггера в рабочем процессе исходящий запрос выполняет вызов для регистрации подписки. Таким образом, триггер может запустить ожидание событий. Когда операция делает этот триггер недопустимым, исходящий запрос автоматически выполняет вызов для отмены подписки. Дополнительные сведения см. в разделе [Подписка конечной точки](#subscribe-unsubscribe).

Можно также указать [ограничения асинхронных операций](#asynchronous-limits) на триггере **HTTPWebhook**.
Поведение триггера зависит от разделов, которые используются или пропускаются. 

```json
"HTTP_Webhook": {
   "type": "HttpWebhook",
   "inputs": {
      "subscribe": {
         "method": "<method-type>",
         "uri": "<endpoint-subscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-method>" },
         "retryPolicy": { "<retry-behavior>" }
         },
      },
      "unsubscribe": {
         "method": "<method-type>",
         "url": "<endpoint-unsubscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-method>" }
      }
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
```

Некоторые значения, например <*method-type*>, доступны для объектов `"subscribe"` и `"unsubscribe"`.

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*method-type*> | Строка | Метод HTTP, используемый для запроса подписки: "GET", "PUT", "POST", "PATCH" или "DELETE" | 
| <*endpoint-subscribe-URL*> | Строка | URL-адрес конечной точки для отправки запроса на подписку | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*method-type*> | Строка | Метод HTTP, используемый для запроса отмены: GET, PUT, POST, PATCH или DELETE | 
| <*endpoint-unsubscribe-URL*> | Строка | URL-адрес конечной точки для отправки запроса на отмену | 
| <*body-content*> | Строка | Любое содержимое сообщения для отправки в запросе на подписку или отмену | 
| <*authentication-method*> | Объект JSON | Метод, используемый запросом для проверки подлинности. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). |
| <*retry-behavior*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*max-runs*> | Целое число  | По умолчанию экземпляры рабочих процессов приложения логики запускаются одновременно или параллельно до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-queue*> | Целое число  | Когда приложение логики уже выполняет максимальное количество экземпляров, которое можно изменить на основе свойства `runtimeConfiguration.concurrency.runs`, все новые запуски помещаются в эту очередь до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*operation-option*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Outputs* 

| Элемент | type | ОПИСАНИЕ |
|---------|------|-------------| 
| Заголовки | Объект JSON | Заголовки из ответа | 
| текст | Объект JSON | Текст из ответа | 
|||| 

*Пример*

Этот триггер создает подписку на указанную конечную точку, предоставляет уникальный URL-адрес обратного вызова и ожидает новых публикаций технологических статей.

```json
"HTTP_Webhook": {
   "type": "HttpWebhook",
   "inputs": {
      "subscribe": {
         "method": "POST",
         "uri": "https://pubsubhubbub.appspot.com/subscribe",
         "body": {
            "hub.callback": "@{listCallbackUrl()}",
            "hub.mode": "subscribe",
            "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
         },
      },
      "unsubscribe": {
         "method": "POST",
         "url": "https://pubsubhubbub.appspot.com/subscribe",
         "body": {
            "hub.callback": "@{workflow().endpoint}@{listCallbackUrl()}",
            "hub.mode": "unsubscribe",
            "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
         }
      }
   }
}
```

<a name="recurrence-trigger"></a>

### <a name="recurrence-trigger"></a>Триггер повторения  

Этот триггер выполняется на основе указанного расписания повторов и предоставляет простой способ создания регулярно запускающегося рабочего процесса. 

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
      "startTime": "<start-date-time-with-format-YYYY-MM-DDThh:mm:ss>",
      "timeZone": "<time-zone>",
      "schedule": {
         // Applies only when frequency is Day or Week. Separate values with commas.
         "hours": [ <one-or-more-hour-marks> ], 
         // Applies only when frequency is Day or Week. Separate values with commas.
         "minutes": [ <one-or-more-minute-marks> ], 
         // Applies only when frequency is Week. Separate values with commas.
         "weekDays": [ "Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday" ] 
      }
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*time-unit*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" | 
| <*number-of-time-units*> | Целое число  | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*start-date-time-with-format-YYYY-MM-DDThh:mm:ss*> | Строка | Дата и время начала в таком формате: <p>ГГГГ-ММ-ДДTчч:мм:сс, если указан часовой пояс, <p>-или- <p>ГГГГ-ММ-ДДTчч:мм:ссZ, если часовой пояс не указан. <p>Например, если требуется указать 18 сентября 2017 г. в 14:00, то используйте 2017-09-18T14:00:00 и укажите часовой пояс, такой как "Стандартное тихоокеанское время", или укажите "2017-09-18T14:00:00Z" без часового пояса. <p>**Примечание.** Это время начала должно соответствовать [спецификации даты и времени ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) в [формате UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time), но без [смещения от UTC](https://en.wikipedia.org/wiki/UTC_offset). Если не указать часовой пояс, то необходимо в конце добавить букву Z без пробелов. Эта буква Z ссылается на соответствующее [судовое время](https://en.wikipedia.org/wiki/Nautical_time). <p>В простых расписаниях время начала определяет первый случай выполнения задания, а в сложных расписаниях триггер срабатывает не раньше, чем наступит время начала. Дополнительные сведения о дате и времени начала см. в статье [Начало работы с триггером повторения](../connectors/connectors-native-recurrence.md). | 
| <*time-zone*> | Строка | Применяется только при указании времени начала, так как этот триггер не принимает [смещение от UTC](https://en.wikipedia.org/wiki/UTC_offset). Укажите часовой пояс, который необходимо применить. | 
| <*one-or-more-hour-marks*> | Целое число или массив целых чисел | Если для параметра `frequency` задать значение Day или Week, то можно указать одно или несколько целых чисел от 0 до 23, разделенных запятыми. В эти часы будет запускаться рабочий процесс. <p>Например, если указать 10, 12 и 14, вы получите часовые метки 10:00, 12:00 и 14:00. | 
| <*one-or-more-minute-marks*> | Целое число или массив целых чисел | Если для параметра `frequency` задать значение Day или Week, то можно указать одно или несколько целых чисел от 0 до 59, разделенных запятыми. В эти минуты часа будет запускаться рабочий процесс. <p>Например, если указать 30 минут и использовать предыдущий пример для часов, то вы получите 10:30, 12:30 и 14:30. | 
| weekDays | Строка или массив строк | Если для параметра `frequency` задать значение Week, то можно указать один или несколько дней, разделенных запятыми. В эти дни будет запускаться рабочий процесс: Monday (Понедельник), Tuesday (Вторник), Wednesday (Среда), Thursday (Четверг), Friday (Пятница), Saturday (Суббота) и Sunday (Воскресенье). | 
| <*max-runs*> | Целое число  | По умолчанию экземпляры рабочих процессов приложения логики запускаются одновременно или параллельно до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-queue*> | Целое число  | Когда приложение логики уже выполняет максимальное количество экземпляров, которое можно изменить на основе свойства `runtimeConfiguration.concurrency.runs`, все новые запуски помещаются в эту очередь до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*operation-option*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Пример 1*

Этот основной триггер повторения запускается ежедневно:

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Day",
      "interval": 1
   }
}
```

*Пример 2*

Вы можете задать дату и время, когда триггер будет срабатывать. Этот триггер повторения будет запущен в соответствии с указанной датой, а затем будет срабатывать ежедневно:

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Day",
      "interval": 1,
      "startTime": "2017-09-18T00:00:00Z"
   }
}
```

*Пример 3*

Этот триггер повторения был запущен 9 сентября 2017 года в 14:00 и запускался каждый понедельник в 10:30, 12:30 и 14:30 по тихоокеанскому времени:

``` json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Week",
      "interval": 1,
      "schedule": {
         "hours": [ 10, 12, 14 ],
         "minutes": [ 30 ],
         "weekDays": [ "Monday" ]
      },
      "startTime": "2017-09-07T14:00:00",
      "timeZone": "Pacific Standard Time"
   }
}
```

Дополнительные сведения, а также примеры это триггера см. в статье [Создание и планирование регулярно выполняющихся задач при помощи Azure Logic Apps](../connectors/connectors-native-recurrence.md).

<a name="request-trigger"></a>

### <a name="request-trigger"></a>Триггер запросов

Этот триггер делает приложение логики вызываемым, создавая конечную точку, которая может принимать входящие запросы. Предоставьте схему JSON для этого триггера, которая описывает и проверяет полезные или входные данные, которые триггер получает от входящего запроса. Схема также упрощает свойства триггеров для ссылки на следующие действия в рабочем процессе. 

Чтобы вызвать этот триггер, необходимо использовать API `listCallbackUrl`, описанный в [REST API службы рабочих процессов](https://docs.microsoft.com/rest/api/logic/workflows). Чтобы узнать, как использовать этот триггер в качестве конечной точки HTTP, см. сведения в статье [Вызовы, срабатывания триггеров и создание вложенных рабочих процессов в приложениях логики](../logic-apps/logic-apps-http-endpoint.md).

```json
"manual": {
   "type": "Request",
   "kind": "Http",
   "inputs": {
      "method": "<method-type>",
      "relativePath": "<relative-path-for-accepted-parameter>",
      "schema": {
         "type": "object",
         "properties": { 
            "<property-name>": {
               "type": "<property-type>"
            }
         },
         "required": [ "<required-properties>" ]
      }
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-run-queue>
      },
   },
   "operationOptions": "<operation-option>"
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*property-name*> | Строка | Имя свойства в схеме JSON, которое описывает полезные данные | 
| <*property-type*> | Строка | Тип свойства | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*method-type*> | Строка | Метод, который входящие запросы должны использовать для вызова приложения логики: GET, PUT, POST, PATCH или DELETE |
| <*relative-path-for-accepted-parameter*> | Строка | Относительный путь для параметра, который принимает URL-адрес конечной точки | 
| <*required-properties*> | Массив, | Одно или несколько свойств, требующих значений | 
| <*max-runs*> | Целое число  | По умолчанию экземпляры рабочих процессов приложения логики запускаются одновременно или параллельно до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-queue*> | Целое число  | Когда приложение логики уже выполняет максимальное количество экземпляров, которое можно изменить на основе свойства `runtimeConfiguration.concurrency.runs`, все новые запуски помещаются в эту очередь до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*operation-option*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Пример*

Этот триггер указывает, что входящий запрос должен использовать HTTP-метод POST для вызова триггера, а также включать схему, проверяющую входные данные входящего запроса. 

```json
"manual": {
   "type": "Request",
   "kind": "Http",
   "inputs": {
      "method": "POST",
      "schema": {
         "type": "object",
         "properties": {
            "customerName": {
               "type": "String"
            },
            "customerAddress": { 
               "type": "Object",
               "properties": {
                  "streetAddress": {
                     "type": "string"
                  },
                  "city": {
                     "type": "string"
                  }
               }
            }
         }
      }
   }
}
```

<a name="trigger-conditions"></a>

## <a name="trigger-conditions"></a>Условия триггера

Для любого триггера можно включить массив, содержащий одно или несколько выражений для условий, определяющих, следует ли запускать рабочий процесс. Чтобы добавить к приложению логики свойство `conditions`, откройте приложение логики в редакторе представления кода.

Например, можно указать, что триггер срабатывает, только если веб-сайт возвращает внутреннюю ошибку сервера, ссылаясь на код состояния триггера в свойстве `conditions`.

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Hour",
      "interval": 1
   },
   "conditions": [ {
      "expression": "@equals(triggers().code, 'InternalServerError')"
   } ]
}
```

По умолчанию триггер срабатывает только после получения ответа "200 OK". Если выражение ссылается на код состояния триггера, стандартный режим работы триггера изменяется. Таким образом, если требуется запуск триггера при более чем одном коде состояния, например "200" и "201", необходимо включить в качестве условия следующее выражение. 

`@or(equals(triggers().code, 200),equals(triggers().code, 201))` 

<a name="split-on-debatch"></a>

## <a name="trigger-multiple-runs"></a>Множественные запуски триггера

Если триггер возвращает массив для обработки приложением логики, цикл for each может занять слишком много времени для обработки каждого элемента массива. Вместо этого можно использовать свойство **SplitOn** в триггере, чтобы выполнить *индивидуальную обработку* массива. При индивидуальной обработке массив разделяется на элементы и для каждого элемента запускается новый экземпляр приложения логики. Такой подход является эффективным, например, если нужно опросить конечную точку, которая может вернуть несколько новых элементов между интервалами опроса.
Максимальное число элементов массива, которое свойство **SplitOn** позволяет обработать в одном приложении логики, см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). 

> [!NOTE]
> Нельзя использовать свойство **SplitOn** с шаблоном синхронного отклика. Любой рабочий процесс, который использует свойство **SplitOn** и содержит действие ответа, выполняется асинхронно и сразу же отправляет ответ `202 ACCEPTED`.

Если в файле триггера Swagger описаны полезные данные, составляющие массив, **SplitOn** автоматически добавляется в триггер. В противном случае добавьте это свойство в полезные данные ответа, содержащий массив, который нужно обработать индивидуально. 

*Пример*

Допустим, что имеется API, который возвращает следующий ответ. 
  
```json
{
   "Status": "Succeeded",
   "Rows": [ 
      { 
         "id": 938109380,
         "name": "customer-name-one"
      },
      {
         "id": 938109381,
         "name": "customer-name-two"
      }
   ]
}
```
 
Приложению логики требуется только содержимое массива `Rows`, поэтому можно создать триггер, как в следующем примере.

``` json
"HTTP_Debatch": {
   "type": "Http",
    "inputs": {
        "uri": "https://mydomain.com/myAPI",
        "method": "GET"
    },
   "recurrence": {
      "frequency": "Second",
      "interval": 1
    },
    "splitOn": "@triggerBody()?.Rows"
}
```

> [!NOTE]
> Если используется команда `SplitOn`, получить свойства, которые находятся за пределами массива, невозможно. В нашем примере получить свойство `status` в ответе, возвращенном из API, невозможно.
> 
> Чтобы избежать ошибок, если отсутствует свойство `Rows`, в этом примере используется оператор `?`.

Теперь в определении рабочего процесса можно использовать `@triggerBody().name`, чтобы получить значения `name`, которые являются значениями `"customer-name-one"` при первом выполнении и `"customer-name-two"` при втором выполнении. Выходные данные триггера выглядят так:

```json
{
   "body": {
      "id": 938109380,
      "name": "customer-name-one"
   }
}
```

```json
{
   "body": {
      "id": 938109381,
      "name": "customer-name-two"
   }
}
```

<a name="actions-overview"></a>

## <a name="actions-overview"></a>Общие сведения о действиях

Azure Logic Apps предоставляет различные типы действий. Каждый из них имеет различные входные данные, которые определяют уникальный режим работы действия. 

Действия включают следующие основные элементы, хотя некоторые из них являются необязательными.

```json
"<action-name>": {
   "type": "<action-type>",
   "inputs": { 
      "<input-name>": { "<input-value>" },
      "retryPolicy": "<retry-behavior>" 
   },
   "runAfter": { "<previous-trigger-or-action-status>" },
   "runtimeConfiguration": { "<runtime-config-options>" },
   "operationOptions": "<operation-option>"
},
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------|
| <*action-name*> | Строка | Имя действия | 
| <*action-type*> | Строка | Тип действия, например Http или ApiConnection| 
| <*input-name*> | Строка | Имя для входа, определяющее поведение действия | 
| <*input-value*> | Различные | Входное значение, которое может быть строкой, целым числом, объектом JSON и т. д. | 
| <*previous-trigger-or-action-status*> | Объект JSON | Имя и итоговое состояние для триггера или действия, которое должно выполняться немедленно перед запуском текущего действия | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------|
| <*retry-behavior*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](#retry-policies). | 
| <*runtime-config-options*> | Объект JSON | Режим работы некоторых действий во время выполнения можно изменить, задав свойство `runtimeConfiguration`. Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options). | 
| <*operation-option*> | Строка | Режим работы по умолчанию некоторых действий можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

## <a name="action-types-list"></a>Список типов действий

Некоторые часто используемые типы действий. 

* [Встроенные типы действий](#built-in-actions), такие как нижеприведенные примеры и многое другое. 

  * [**HTTP**](#http-action) для вызова конечных точек через HTTP или HTTPS

  * [**Ответ**](#response-action) для реагирования на запросы

  * [**Функция**](#function-action) для вызова службы "Функции Azure"

  * Действия обработки данных, такие как [**Соединить**](#join-action), [**Создать**](#compose-action), [**Таблица**](#table-action), [**Выбрать**](#select-action) и другие, которые создают или преобразовывают данные из различных входов

  * [**Рабочий процесс**](#workflow-action) для вызова рабочего процесса другого приложения логики

* [Типы действий управляемых API](#managed-api-actions), такие как [**ApiConnection**](#apiconnection-action) и [**ApiConnectionWebHook**](#apiconnectionwebhook-action), которые вызывают различные соединители и управляемые Майкрософт интерфейсы API, например Служебная шина Azure, Office 365 Outlook, Power BI, хранилище BLOB-объектов Azure, OneDrive, GitHub и т. д.

* [Типы действий рабочего процесса управления](#control-workflow-actions), такие как [**If**](#if-action), [**Foreach**](#foreach-action), [**Switch**](#switch-action), [**Scope**](#scope-action) и [**Until**](#until-action), которые содержат другие действия и помогают организовать выполнение рабочего процесса

<a name="built-in-actions"></a>

### <a name="built-in-actions"></a>Встроенные действия

| Тип действия | ОПИСАНИЕ | 
|-------------|-------------| 
| [**Создать**](#compose-action) | Создает один выход из входных данных, который может иметь различные типы. | 
| [**Функция**](#function-action) | Вызывает функцию Azure. | 
| [**HTTP**](#http-action) | Вызывает конечную точку HTTP. | 
| [**Соединить**](#join-action) | Создает строку из всех элементов в массиве и разделяет эти элементы определенным символом разделителя. | 
| [**Анализ JSON**](#parse-json-action) | Создает понятные токены из свойств в содержимом JSON. Затем можно ссылаться на эти свойства, включая токены в приложение логики. | 
| [**Запрос**](#query-action) | Создает массив из элементов другого массива на основании условия или фильтра. | 
| [**Ответ**](#response-action) | Создает ответ на входящий вызов или запрос. | 
| [**Выбрать**](#select-action) | Создает массив объектов JSON, преобразуя элементы другого массива на основе указанной карты. | 
| [**Таблица**](#table-action) | Создает таблицу CSV или HTML из массива. | 
| [**Завершить**](#terminate-action) | Останавливает активное выполнение рабочего процесса. | 
| [**Ожидание**](#wait-action) | Приостанавливает рабочий процесс на заданный срок или до указанной даты и времени. | 
| [**Рабочий процесс**](#workflow-action) | Создает вложенный рабочий процесс внутри другого рабочего процесса. | 
||| 

<a name="managed-api-actions"></a>

### <a name="managed-api-actions"></a>Действия управляемых API

| Тип действия | ОПИСАНИЕ | 
|-------------|-------------|  
| [**ApiConnection**](#apiconnection-action) | Вызывает конечную точку HTTP, используя [управляемый Майкрософт интерфейс API](../connectors/apis-list.md). | 
| [**ApiConnectionWebhook**](#apiconnectionwebhook-action) | Работает как веб-перехватчик HTTP, но использует [интерфейс API, управляемый Майкрософт](../connectors/apis-list.md). | 
||| 

<a name="control-workflow-actions"></a>

### <a name="control-workflow-actions"></a>Действия рабочего процесса управления

Эти действия позволяют управлять выполнением рабочего процесса и включают в себя другие действия. За пределами действия рабочего процесса управления можно непосредственно ссылаться на действия внутри него. Например, если имеется действие `Http` внутри области, можно ссылаться на выражение `@body('Http')` из любой точки в рабочем процессе. В то же время действия, которые существуют внутри действия рабочего процесса управления, могут "привязываться" только к другим действиям, которые находятся в той же структуре рабочего процесса управления.

| Тип действия | ОПИСАНИЕ | 
|-------------|-------------| 
| [**Foreach**](#foreach-action) | Выполняет те же действия в цикле для каждого элемента массива. | 
| [**If**](#if-action) | Выполняет действия в зависимости от того, имеет ли заданное условие значение true или false. | 
| [**Scope**](#scope-action) | Выполняет действия из набора действий на основе состояния группы. | 
| [**Switch**](#switch-action) | Выполняет действия, организованные в случаях, когда значения из выражений, объектов или токенов соответствуют значениям, указанным для каждого случая. | 
| [**Until**](#until-action) | Выполняет действия в цикле до тех пор, пока указанное условие не будет иметь значение true. | 
|||  

## <a name="actions---detailed-reference"></a>Действия. Подробная справочная информация

<a name="apiconnection-action"></a>

### <a name="apiconnection-action"></a>Действие APIConnection

Это действие отправляет HTTP-запрос для [управляемого Microsoft интерфейса API](../connectors/apis-list.md) и требует сведения об API и параметрах, а также ссылку на действительное соединение. 

``` json
"<action-name>": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<api-name>']['connectionId']"
         },
         "<other-action-specific-input-properties>"        
      },
      "method": "<method-type>",
      "path": "/<api-operation>",
      "retryPolicy": "<retry-behavior>",
      "queries": { "<query-parameters>" },
      "<other-action-specific-properties>"
    },
    "runAfter": {}
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*action-name*> | Строка | Имя действия, предоставляемого соединителем | 
| <*api-name*> | Строка | Имя управляемого Майкрософт интерфейса API, используемого для подключения | 
| <*method-type*> | Строка | Метод HTTP для вызова API: GET, PUT, POST, PATCH или DELETE | 
| <*api-operation*> | Строка | Операция API для вызова | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*other-action-specific-input-properties*> | Объект JSON | Все входные свойства, которые применяются к указанному действию | 
| <*retry-behavior*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*query-parameters*> | Объект JSON | Все параметры запроса для включения с помощью вызова API. <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*other-action-specific-properties*> | Объект JSON | Все другие свойства, которые применяются к указанному действию | 
|||| 

*Пример*

Это определение описывает действие **Отправить по электронной почте** для соединителя Outlook Office 365, который является управляемым Майкрософт интерфейсом API. 

```json
"Send_an_email": {
   "type": "ApiConnection",
   "inputs": {
      "body": {
         "Body": "Thank you for your membership!",
         "Subject": "Hello and welcome!",
         "To": "Sophie.Owen@contoso.com"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "POST",
      "path": "/Mail"
    },
    "runAfter": {}
}
```

<a name="apiconnection-webhook-action"></a>

### <a name="apiconnectionwebhook-action"></a>Действие APIConnectionWebhook

Это действие отправляет запрос на подписку через HTTP в конечную точку с помощью [управляемого Майкрософт интерфейсом API](../connectors/apis-list.md), предоставляет *URL-адрес обратного вызова*, на который конечная точка может отправить ответ, и ожидает ответа конечной точки. Дополнительные сведения см. в разделе [Подписка конечной точки](#subscribe-unsubscribe).

```json
"<action-name>": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "subscribe": {
         "method": "<method-type>",
         "uri": "<api-subscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-method>" },
         "retryPolicy": "<retry-behavior>",
         "queries": { "<query-parameters>" },
         "<other-action-specific-input-properties>"
      },
      "unsubscribe": {
         "method": "<method-type>",
         "uri": "<api-unsubscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-method>" },
         "<other-action-specific-properties>"
      },
   },
   "runAfter": {}
}
```

Некоторые значения, например <*method-type*>, доступны для объектов `"subscribe"` и `"unsubscribe"`.

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*action-name*> | Строка | Имя действия, предоставляемого соединителем | 
| <*method-type*> | Строка | Метод HTTP для подписки или отмены подписки на конечную точку: GET, PUT, POST, PATCH или DELETE | 
| <*api-subscribe-URL*> | Строка | Универсальный код ресурса (URI), используемый для подписки на API | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*api-unsubscribe-URL*> | Строка | Универсальный код ресурса (URI), используемый для отмены подписки на API | 
| <*header-content*> | Объект JSON | Все заголовки для отправки в запрос <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| <*body-content*> | Объект JSON | Любое содержимое сообщения для отправки в запросе | 
| <*authentication-method*> | Объект JSON | Метод, используемый запросом для проверки подлинности. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). |
| <*retry-behavior*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*query-parameters*> | Объект JSON | Все параметры запроса для включения в вызов API <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*other-action-specific-input-properties*> | Объект JSON | Все входные свойства, которые применяются к указанному действию | 
| <*other-action-specific-properties*> | Объект JSON | Все другие свойства, которые применяются к указанному действию | 
|||| 

Также можно указать ограничения для действий **ApiConnectionWebhook** так же, как [ограничения асинхронных операций HTTP](#asynchronous-limits).

<a name="compose-action"></a>

### <a name="compose-action"></a>Действие compose

Это действие создает один вывод из нескольких входных данных, включая выражения. Оба входа и выхода могут иметь любой тип, поддерживаемый Azure Logic Apps, например массивы, объекты JSON, язык XML и двоичные объекты.
Затем можно использовать выходные данные действия в других действиях. 

```json
"Compose": {
   "type": "Compose",
   "inputs": "<inputs-to-compose>",
   "runAfter": {}
},
```

*Обязательный* 

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*inputs-to-compose*> | Любой | Входные данные для создания единых выходных данных | 
|||| 

*Пример 1*

Это определение действия объединяет `abcdefg ` с конечным пространством и значением `1234`.

```json
"Compose": {
   "type": "Compose",
   "inputs": "abcdefg 1234",
   "runAfter": {}
},
```

Результат, который создает это действие.

`abcdefg 1234`

*Пример 2*

Это определение действия объединяет строковую переменную, содержащую `abcdefg` и целочисленную переменную, которая содержит `1234`.

```json
"Compose": {
   "type": "Compose",
   "inputs": "@{variables('myString')}@{variables('myInteger')}",
   "runAfter": {}
},
```

Результат, который создает это действие.

`"abcdefg1234"`

<a name="function-action"></a>

### <a name="function-action"></a>Действие функции

Это действие вызывает ранее созданный объект [Функция Azure](../azure-functions/functions-create-first-azure-function.md).

```json
"<Azure-function-name>": {
   "type": "Function",
   "inputs": {
     "function": {
        "id": "<Azure-function-ID>"
      },
      "method": "<method-type>",
      "headers": { "<header-content>" },
      "body": { "<body-content>" },
      "queries": { "<query-parameters>" } 
   },
   "runAfter": {}
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------|  
| <*Azure-function-ID*> | Строка | Идентификатор ресурса для функции Azure, которую требуется вызвать. Формат для этого значения:<p>"/subscriptions/<*Azure-subscription-ID*>/resourceGroups/<*Azure-resource-group*>/providers/Microsoft.Web/sites/<*Azure-function-app-name*>/functions/<*Azure-function-name*>" | 
| <*method-type*> | Строка | Метод HTTP, используемый для вызова функции: GET, PUT, POST, PATCH или DELETE <p>Если метод не указан, то по умолчанию используется метод POST. | 
||||

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------|  
| <*header-content*> | Объект JSON | Все заголовки для отправки с вызовом <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| <*body-content*> | Объект JSON | Любое содержимое сообщения для отправки в запросе | 
| <*query-parameters*> | Объект JSON | Все параметры запроса для включения в вызов API <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*other-action-specific-input-properties*> | Объект JSON | Все входные свойства, которые применяются к указанному действию | 
| <*other-action-specific-properties*> | Объект JSON | Все другие свойства, которые применяются к указанному действию | 
||||

При сохранении приложения логики модуль Logic Apps выполняет эти проверки указанной функции.

* У рабочего процесса должен быть доступ к функции.

* Рабочий процесс может использовать только стандартный триггер HTTP или универсальный триггер веб-перехватчика в формате JSON. 

  Модуль Logic Apps получает и кэширует URL-адрес триггера, используемый в среде выполнения. Тем не менее, если какая-либо операция делает недействительным кэшированный URL-адрес, то в среде выполнения действие **Функция** заканчивается сбоем. Чтобы устранить эту проблему, повторно сохраните приложение логики, чтобы оно снова загрузило URL-адрес триггера.

* Функция не может иметь какой-либо определенный маршрут.

* Можно использовать только авторизацию с помощью функции и анонимную авторизацию. 

*Пример*

Это определение действия вызывает ранее созданную функцию GetProductID.

```json
"GetProductID": {
   "type": "Function",
   "inputs": {
     "function": {
        "id": "/subscriptions/<XXXXXXXXXXXXXXXXXXXX>/resourceGroups/myLogicAppResourceGroup/providers/Microsoft.Web/sites/InventoryChecker/functions/GetProductID"
      },
      "method": "POST",
      "headers": { 
          "x-ms-date": "@utcnow()"
       },
      "body": { 
          "Product_ID": "@variables('ProductID')"
      }
   },
   "runAfter": {}
}
```

<a name="http-action"></a>

### <a name="http-action"></a>Действие HTTP

Это действие отсылает запрос на указанную конечную точку и проверяет ответ, чтобы определить, следует ли запускать рабочий процесс. 

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "<method-type>",
      "uri": "<HTTP-or-HTTPS-endpoint-URL>"
   },
   "runAfter": {}
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*method-type*> | Строка | Метод для отправки запроса: GET, PUT, POST, PATCH или DELETE | 
| <*HTTP-or-HTTPS-endpoint-URL*> | Строка | Конечная точка HTTP или HTTPS для вызова. Максимальный размер строки: 2 КБ. | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*header-content*> | Объект JSON | Все заголовки для отправки с запросом <p>Пример задания языка и типа. <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| <*body-content*> | Объект JSON | Любое содержимое сообщения для отправки в запросе | 
| <*retry-behavior*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*query-parameters*> | Объект JSON | Все параметры запроса для включения с помощью запроса <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*other-action-specific-input-properties*> | Объект JSON | Все входные свойства, которые применяются к указанному действию | 
| <*other-action-specific-properties*> | Объект JSON | Все другие свойства, которые применяются к указанному действию | 
|||| 

*Пример*

Это определение действия получает последние новости, отправив запрос на указанную конечную точку.

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "https://mynews.example.com/latest"
   }
}
```

<a name="join-action"></a>

### <a name="join-action"></a>Действие "Соединить"

Это действие создает строку из всех элементов в массиве и разделяет эти элементы определенным символом разделителя. 

```json
"Join": {
   "type": "Join",
   "inputs": {
      "from": <array>,
      "joinWith": "<delimiter>"
   },
   "runAfter": {}
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*array*> | Массив, | Массив или выражение, которое предоставляет исходные элементы. Если задано выражение, заключите его в двойные кавычки. | 
| <*delimiter*> | Единая строка символов | Символ, разделяющий каждый элемент в строке | 
|||| 

*Пример*

Предположим, что у вас есть ранее созданная переменная myIntegerArray, содержащая этот массив целых чисел. 

`[1,2,3,4]` 

Это определение действия получает значения из переменной с помощью функции `variables()` в выражении и создает эту строку с теми значениями, которые разделяются запятыми: `"1,2,3,4"`.

```json
"Join": {
   "type": "Join",
   "inputs": {
      "from": "@variables('myIntegerArray')",
      "joinWith": ","
   },
   "runAfter": {}
}
```

<a name="parse-json-action"></a>

### <a name="parse-json-action"></a>Действие "Анализ JSON"

Это действие создает удобные пользовательские поля или *токены* из свойств в содержимом JSON. Затем можно получить доступ к этим свойствам в своем приложении логики, используя вместо этого токены. Например, если необходимо использовать выходные данные JSON таких служб как Служебная шина Azure и Azure Cosmos DB, можно включить это действие в своем приложении логики, чтобы иметь возможность легче ссылаться на выходные данные. 

```json
"Parse_JSON": {
   "type": "ParseJson",
   "inputs": {
      "content": "<JSON-source>",
         "schema": { "<JSON-schema>" }
      },
      "runAfter": {}
},
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*JSON-source*> | Объект JSON | Содержимое JSON, которое необходимо анализировать | 
| <*JSON-schema*> | Объект JSON | Схема JSON, описывающая основное содержимое JSON, которое использует действие для анализа исходного содержимого JSON. <p>**Совет**. В Конструкторе Logic Apps можно указать схему или предоставить пример полезных данных, чтобы действие могло создать схему. | 
|||| 

*Пример*

Это определение действия создает эти маркеры, которые можно использовать в рабочем процессе приложения логики, но только в действиях, выполняемых после действия **Анализ JSON**: 

`FirstName`, `LastName` и `Email`.

```json
"Parse_JSON": {
   "type": "ParseJson",
   "inputs": {
      "content": {
         "Member": {
            "Email": "Sophie.Owen@contoso.com",
            "FirstName": "Sophie",
            "LastName": "Owen"
         }
      },
      "schema": {
         "type": "object",
         "properties": {
            "Member": {
               "type": "object",
               "properties": {
                  "Email": {
                     "type": "string"
                  },
                  "FirstName": {
                     "type": "string"
                  },
                  "LastName": {
                     "type": "string"
                  }
               }
            }
         }
      }
   },
   "runAfter": { }
},
```

В этом примере свойство content указывает содержимое JSON для анализа. Также можно предоставить это содержимое JSON как пример полезных данных для создания схемы.

```json
"content": {
   "Member": { 
      "FirstName": "Sophie",
      "LastName": "Owen",
      "Email": "Sophie.Owen@contoso.com"
   }
},
```

Свойство schema указывает схему JSON, используемую для описания содержимого JSON.

```json
"schema": {
   "type": "object",
   "properties": {
      "Member": {
         "type": "object",
         "properties": {
            "FirstName": {
               "type": "string"
            },
            "LastName": {
               "type": "string"
            },
            "Email": {
               "type": "string"
            }
         }
      }
   }
}
```

<a name="query-action"></a>

### <a name="query-action"></a>Действие запроса

Это действие создает массив из элементов другого массива на основании указанного условия или фильтра.

```json
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": <array>,
      "where": "<condition-or-filter>"
   },
   "runAfter": {}
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*array*> | Массив, | Массив или выражение, которое предоставляет исходные элементы. Если задано выражение, заключите его в двойные кавычки. |
| <*condition-or-filter*> | Строка | Условие, используемое для фильтрации элементов в массиве источника <p>**Примечание**. Если нет значений, соответствующих условию, действие создает пустой массив. |
|||| 

*Пример*

Это определение действия создает массив, содержащий значения, превышающие указанное значение, которое равно двум.

```json
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": [ 1, 3, 0, 5, 4, 2 ],
      "where": "@greater(item(), 2)"
   }
}
```

<a name="response-action"></a>

### <a name="response-action"></a>Действие ответа  

Это действие создает полезные данные для ответа на запрос HTTP. 

```json
"Response" {
    "type": "Response",
    "kind": "http",
    "inputs": {
        "statusCode": 200,
        "headers": { <response-headers> },
        "body": { <response-body> }
    },
    "runAfter": {}
},
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*response-status-code*> | Целое число  | Код состояния HTTP, отправленный на входящий запрос. Код по умолчанию является "200 OK", но это может быть любой допустимый код состояния, который начинается с 2xx, 4xx или 5xx, но не с 3xxx. | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*response-headers*> | Объект JSON | Один или несколько заголовков для включения в ответ | 
| <*response-body*> | Различные | Текст ответа, который может быть строкой, объектом JSON или даже двоичным содержимым из предыдущего действия | 
|||| 

*Пример*

Это определение действия создает ответ на HTTP-запрос с заданным кодом статуса, текстом сообщения и заголовком сообщения.

```json
"Response": {
   "type": "Response",
   "inputs": {
      "statusCode": 200,
      "body": {
         "ProductID": 0,
         "Description": "Organic Apples"
      },
      "headers": {
         "x-ms-date": "@utcnow()",
         "content-type": "application/json"
      }
   },
   "runAfter": {}
}
```

*Ограничения*

В отличии от других, действие **Ответ** имеет специальные ограничения. 

* Рабочий процесс может использовать действие **Ответ** только тогда, когда он начинается с триггера запроса HTTP, это значит, что рабочий процесс должен запускаться HTTP-запросом.

* Рабочий процесс может использовать действие **Ответ** в любом месте, *кроме* как внутри циклов **Foreach**, **Until**, включая последовательные циклы и параллельные ветви. 

* Первоначальный HTTP-запрос получает ответ рабочего процесса только тогда, когда все действия, требуемые действием **Ответ**, завершены в [пределах времени ожидания HTTP-запроса](../logic-apps/logic-apps-limits-and-config.md#request-limits).

  Однако, если рабочий процесс вызывает другое приложение логики в качестве вложенного рабочего процесса, родительский рабочий процесс ожидает завершения вложенного рабочего процесса, независимо от того, сколько времени прошло до его завершения.

* Когда рабочий процесс использует действие **Ответ** и синхронный шаблон ответа, он не может использовать команду **splitOn** в определении триггера, потому что эта команда создает несколько запусков. Проверьте этот случай, когда используется метод PUT, и если значение равно true, вернется ответ "Недопустимый запрос".

  В противном случае, если рабочий процесс использует команду **splitOn** и действие **Ответ**, рабочий процесс выполняется асинхронно и немедленно возвращает ответ "202 ACCEPTED".

* Когда выполнение рабочего процесса достигает действия **Ответ**, но входящий запрос уже получил ответ, действие **Ответ** помечается как Failed (Сбой) из-за конфликта. И в результате выполнения приложения логики также отмечается состояние Failed (Сбой).

<a name="select-action"></a>

### <a name="select-action"></a>Выбор действия

Это действие создает массив с объектами JSON путем преобразования элементов из другого массива на основе указанного сопоставления. Выходной и исходный массив всегда имеет одинаковое количество элементов. Несмотря на то что невозможно изменить количество объектов в выходном массиве, можно добавлять или удалять свойства и их значения в этих объектах. Свойство `select` указывает по меньшей мере одну пару "ключ — значение", определяющую сопоставление для преобразования элементов в исходном массиве. Пара "ключ — значение" представляет свойство и его значение во всех объектах выходного массива. 

```json
"Select": {
   "type": "Select",
   "inputs": {
      "from": <array>,
      "select": { 
          "<key-name>": "<expression>",
          "<key-name>": "<expression>"        
      }
   },
   "runAfter": {}
},
```

*Обязательный* 

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*array*> | Массив, | Массив или выражение, которое предоставляет исходные элементы. Убедитесь, что выражение заключено в двойные кавычки. <p>**Примечание**. Если исходный массив пуст, это действие создает пустой массив. | 
| <*key-name*> | Строка | Имя свойства, назначенное в результате <*expression*> <p>Чтобы добавить новое свойство во всех объектах в выходном массиве, предоставьте <*key-name*> для этого свойства и объект <*expression*> для значения свойства. <p>Чтобы удалить свойство из всех объектов в массиве, опустите <*key-name*> для этого свойства. | 
| <*expression*> | Строка | Выражение, которое преобразует элемент в исходном массиве и присваивает результат для <*key-name*> | 
|||| 

Действие **Выбрать** создает массив как вывод, поэтому любое действие, которое хочет использовать этот вывод, должно либо принимать массив, либо необходимо преобразовать массив в тип, который принимает действие пользователя. Например, чтобы преобразовать выходной массив в строку, передайте массив в действие **Создать**, а затем ссылайтесь на результат действия **Создать** в других действиях.

*Пример*

Это определение действия создает массив объектов JSON из массива целых чисел. Действие повторяется с исходным массивом, получает каждое целочисленное значение с помощью выражения `@item()` и присваивает каждому значению свойство "`number`" в каждом объекте JSON. 

```json
"Select": {
   "type": "Select",
   "inputs": {
      "from": [ 1, 2, 3 ],
      "select": { 
         "number": "@item()" 
      }
   },
   "runAfter": {}
},
```

Массив, который создает это действие.

`[ { "number": 1 }, { "number": 2 }, { "number": 3 } ]`

Чтобы использовать этот массив выходных данных в других действиях, передайте этот результат в действие **Создать**.

```json
"Compose": {
   "type": "Compose",
   "inputs": "@body('Select')",
   "runAfter": {
      "Select": [ "Succeeded" ]
   }
},
```

Затем можно использовать вывод из действия **Создать** в других действиях, например **Office 365 Outlook: отправить по электронной почте**.

```json
"Send_an_email": {
   "type": "ApiConnection",
   "inputs": {
      "body": {
         "Body": "@{outputs('Compose')}",
         "Subject": "Output array from Select and Compose actions",
         "To": "<your-email@domain>"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "post",
      "path": "/Mail"
   },
   "runAfter": {
      "Compose": [ "Succeeded" ]
   }
},
```

<a name="table-action"></a>

### <a name="table-action"></a>Действие таблицы

Это действие создает таблицу CSV или HTML из массива. Для массивов с объектами JSON это действие автоматически создает заголовки столбцов с именами свойств объектов. Для массивов с другими типами данных необходимо указать заголовки столбцов и значений. Например, этот массив содержит свойства ID и Product_Name, которые могут использовать это действие для заголовков столбцов.

`[ {"ID": 0, "Product_Name": "Apples"}, {"ID": 1, "Product_Name": "Oranges"} ]` 

```json
"Create_<CSV | HTML>_table": {
   "type": "Table",
   "inputs": {
      "format": "<CSV | HTML>",
      "from": <array>,
      "columns": [ 
         {
            "header": "<column-name>",
            "value": "<column-value>"
         },
         {
            "header": "<column-name>",
            "value": "<column-value>"
         } 
      ]
   },
   "runAfter": {}
}
```

*Обязательный* 

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <CSV *или* HTML>| Строка | Формат таблицы, которую необходимо создать | 
| <*array*> | Массив, | Массив или выражение, которое предоставляет исходные элементы для таблицы <p>**Примечание**. Если исходный массив пуст, это действие создает пустую таблицу. | 
|||| 

*Необязательно.*

Чтобы задать или настроить заголовки столбцов и значения, используйте массив `columns`. Когда пары `header-value` имеют одинаковое имя заголовка, их значения отображаются в том же столбце под этим заголовком. В противном случае каждый уникальный заголовок определяет уникальный столбец.

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*column-name*> | Строка | Имя заголовка столбца | 
| <*column-value*> | Любой | Значение в столбце | 
|||| 

*Пример 1*

Предположим, что имеется ранее созданная переменная myItemArray, содержащая в данный момент этот массив. 

`[ {"ID": 0, "Product_Name": "Apples"}, {"ID": 1, "Product_Name": "Oranges"} ]`

Это определение действия создает таблицу CSV из переменной myItemArray. Выражение, использующее свойство `from`, возвращает массив из myItemArray с помощью функции `variables()`. 

```json
"Create_CSV_table": {
   "type": "Table",
   "inputs": {
      "format": "CSV",
      "from": "@variables('myItemArray')"
   },
   "runAfter": {}
}
```

Таблица CSV, которая создает это действие. 

```
ID,Product_Name 
0,Apples 
1,Oranges 
```

*Пример 2*

Это определение действия создает таблицу HTML из переменной myItemArray. Выражение, использующее свойство `from`, возвращает массив из myItemArray с помощью функции `variables()`. 

```json
"Create_HTML_table": {
   "type": "Table",
   "inputs": {
      "format": "HTML",
      "from": "@variables('myItemArray')"
   },
   "runAfter": {}
}
```

Таблица HTML, которая создает это действие. 

<table><thead><tr><th>ИД</th><th>Product_name</th></tr></thead><tbody><tr><td>0</td><td>Яблоки</td></tr><tr><td>1</td><td>Апельсины</td></tr></tbody></table>

*Пример 3*

Это определение действия создает таблицу HTML из переменной myItemArray. Однако этот пример переопределяет имена заголовков столбцов по умолчанию с помощью Stock_ID и Description и добавляет слово Organic к значениям в столбце Description.

```json
"Create_HTML_table": {
   "type": "Table",
   "inputs": {
      "format": "HTML",
      "from": "@variables('myItemArray')",
      "columns": [ 
         {
            "header": "Stock_ID",
            "value": "@item().ID"
         },
         {
            "header": "Description",
            "value": "@concat('Organic ', item().Product_Name)"
         }
      ]
    },
   "runAfter": {}
},
```

Таблица HTML, которая создает это действие. 

<table><thead><tr><th>Stock_ID</th><th>ОПИСАНИЕ</th></tr></thead><tbody><tr><td>0</td><td>Органические яблоки</td></tr><tr><td>1</td><td>Органические апельсины</td></tr></tbody></table>

<a name="terminate-action"></a>

### <a name="terminate-action"></a>Действие terminate

Это действие останавливает выполнение экземпляра рабочего процесса приложения логики, отменяет все выполняемые действия, пропуская все оставшиеся действия, и возвращает указанное состояние. Например, можно использовать действие **Завершить**, когда приложение логики должно полностью выйти из состояния ошибки. Это действие не влияет на уже выполненные действия и не может указываться в циклах **Foreach** и **Until**, включая последовательные циклы. 

```json
"Terminate": {
   "type": "Terminate",
   "inputs": {
       "runStatus": "<status>",
       "runError": {
            "code": "<error-code-or-name>",
            "message": "<error-message>"
       }
   },
   "runAfter": {}
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*status*> | Строка | Состояние для возврата запуска: Failed (Сбой), Cancelled (Отменено) или Succeeded (Успешно) |
|||| 

*Необязательно.*

Свойства для объекта runStatus применяются только в том случае, если свойству runStatus присвоено состояние Failed (Сбой).

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*error-code-or-name*> | Строка | Код или имя ошибки |
| <*error-message*> | Строка | Сообщение или текст, описывающий ошибку и любые действия, которые пользователь приложения может предпринять | 
|||| 

*Пример*

Это определение действия останавливает выполнение рабочего процесса, устанавливает статус запуска как Failed (Сбой) и возвращает состояние, код ошибки и сообщение об ошибке.

```json
"Terminate": {
    "type": "Terminate",
    "inputs": {
        "runStatus": "Failed",
        "runError": {
            "code": "Unexpected response",
            "message": "The service received an unexpected response. Please try again."
        }
   },
   "runAfter": {}
}
```

<a name="wait-action"></a>

### <a name="wait-action"></a>Действие wait  

Это действие приостанавливает выполнение рабочего процесса на указанный период времени или до указанного времени, но не для обоих. 

*Указанный интервал*

```json
"Delay": {
   "type": "Wait",
   "inputs": {
      "interval": {
         "count": <number-of-units>,
         "unit": "<interval>"
      }
   },
   "runAfter": {}
},
```

*Указанное время*

```json
"Delay_until": {
   "type": "Wait",
   "inputs": {
      "until": {
         "timestamp": "<date-time-stamp>"
      }
   },
   "runAfter": {}
},
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*number-of-units*> | Целое число  | Число единиц ожидания для действия **Задержка** | 
| <*interval*> | Строка | Для действия **Задержка** период ожидания составляет: "секунда", "минута", "час", "день", "неделя", "месяц" | 
| <*date-time-stamp*> | Строка | Дата и время возобновления исполнения для действия **Задержка до**. Для этого значения необходимо использовать [дату и время в формате UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). | 
|||| 

*Пример 1*

Это определение действия приостанавливает рабочий процесс на 15 минут.

```json
"Delay": {
   "type": "Wait",
   "inputs": {
      "interval": {
         "count": 15,
         "unit": "Minute"
      }
   },
   "runAfter": {}
},
```

*Пример 2*

Это определение действия приостанавливает рабочий процесс до указанного времени.

```json
"Delay_until": {
   "type": "Wait",
   "inputs": {
      "until": {
         "timestamp": "2017-10-01T00:00:00Z"
      }
   },
   "runAfter": {}
},
```

<a name="workflow-action"></a>

### <a name="workflow-action"></a>Действие workflow

Это действие вызывает другое ранее созданное приложение логики, это значит, что можно включать и повторно использовать другие рабочие процессы приложений логики. Также можно использовать выходы из дочернего или *вложенного* приложения логики в действиях, следующих за вложенным приложением логики, при условии, что дочернее приложение логики возвращает ответ.

Модуль Logic Apps проверяет доступ к триггеру, который необходимо вызвать, поэтому убедитесь, что вы можете получить доступ к этому триггеру. Кроме того, вложенное приложение логики должно соответствовать следующим критериям.

* Триггер делает вложенное приложение логики вызываемым, наподобие триггеров [Запрос](#request-trigger) или [HTTP](#http-trigger)

* Та же подписка Azure, что и родительское приложение логики

* Чтобы использовать выходы из вложенного приложения логики в родительском приложении логики, вложенное приложение логики должно иметь действие [Ответ](#response-action) 

```json
"<nested-logic-app-name>": {
   "type": "Workflow",
   "inputs": {
      "body": { "<body-content" },
      "headers": { "<header-content>" },
      "host": {
         "triggerName": "<trigger-name>",
         "workflow": {
            "id": "/subscriptions/<Azure-subscription-ID>/resourceGroups/<Azure-resource-group>/providers/Microsoft.Logic/<nested-logic-app-name>"
         }
      }
   },
   "runAfter": {}
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*nested-logic-app-name*> | Строка | Имя приложения логики, которое требуется вызвать | 
| <*trigger-name*> | Строка | Имя триггера вложенного приложения логики, которое необходимо вызвать | 
| <*Azure-subscription-ID*> | Строка | Идентификатор подписки Azure вложенного приложения логики |
| <*Azure-resource-group*> | Строка | Группа ресурсов Azure вложенного приложения логики |
| <*nested-logic-app-name*> | Строка | Имя приложения логики, которое требуется вызвать |
||||

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------|  
| <*header-content*> | Объект JSON | Все заголовки для отправки с вызовом | 
| <*body-content*> | Объект JSON | Любое содержимое сообщения для отправки с вызовом | 
||||

*Outputs*

Выходные данные этого действия различаются в зависимости от действия "Ответ" вложенного приложения логики. Если вложенное приложение логики не включает действие "Ответ", выходные данные будут пустыми.

*Пример*

После успешного завершения действия Start_search это определение действия рабочего процесса вызывает другое приложение логики с именем Get_product_information, которое передается в заданные входы. 

```json
"actions": {
   "Start_search": { <action-definition> },
   "Get_product_information": {
      "type": "Workflow",
      "inputs": {
         "body": {
            "ProductID": "24601",
         },
         "host": {
            "id": "/subscriptions/XXXXXXXXXXXXXXXXXXXXXXXXXX/resourceGroups/InventoryManager-RG/providers/Microsoft.Logic/Get_product_information",
            "triggerName": "Find_product"
         },
         "headers": {
            "content-type": "application/json"
         }
      },
      "runAfter": { 
         "Start_search": [ "Succeeded" ]
      }
   }
},
```

## <a name="control-workflow-action-details"></a>Сведения о действиях рабочего процесса управления

<a name="foreach-action"></a>

### <a name="foreach-action"></a>Действие foreach

Это циклическое действие выполняет итерацию по массиву и действия с каждым элементом массива. По умолчанию цикл Foreach выполняется в параллельном режиме, вплоть до максимального числа циклов. Дополнительные сведения о максимальных числах циклов см. в разделе [Ограничения и конфигурация](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Дополнительные сведения см. в разделе [Цикл Foreach](../logic-apps/logic-apps-control-flow-loops.md#foreach-loop).

```json
"For_each": {
   "type": "Foreach",
   "actions": { 
      "<action-1>": { "<action-definition-1>" },
      "<action-2>": { "<action-definition-2>" }
   },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": <count>
      }
    },
    "operationOptions": "<operation-option>"
}
```

*Обязательный* 

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*action-1...n*> | Строка | Имена действий, выполняемых над каждым элементом массива | 
| <*action-definition-1...n*> | Объект JSON | Определения действий, которые выполняются | 
| <*for-each-expression*> | Строка | Выражение, которое ссылается на каждый элемент в указанном массиве | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*count*> | Целое число  | По умолчанию итерации цикла Foreach запускаются одновременно или параллельно до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма цикла Foreach](#change-for-each-concurrency). | 
| <*operation-option*> | Строка | Чтобы запустить цикл Foreach последовательно, а не параллельно, задайте <*operation-option*> для `Sequential` или <*count*> для `1`, но не для обоих. Дополнительные сведения см. в разделе [Последовательный запуск циклов Foreach](#sequential-for-each). | 
|||| 

*Пример*

Этот цикл Foreach отправляет электронное письмо для каждого элемента массива, содержащего вложения из входящего письма. Цикл отправляет электронное письмо, включая вложение, пользователю, который рассматривает вложение.

```json
"For_each": {
   "type": "Foreach",
   "actions": {
      "Send_an_email": {
         "type": "ApiConnection",
         "inputs": {
            "body": {
               "Body": "@base64ToString(items('For_each')?['Content'])",
               "Subject": "Review attachment",
               "To": "Sophie.Owen@contoso.com"
                },
            "host": {
               "connection": {
                  "id": "@parameters('$connections')['office365']['connectionId']"
               }
            },
            "method": "post",
            "path": "/Mail"
         },
         "runAfter": {}
      }
   },
   "foreach": "@triggerBody()?['Attachments']",
   "runAfter": {}
}
```

Чтобы указать только массив, который передается в качестве выходных данных из триггера, это выражение получает массив <*array-name*> из текста триггера. Чтобы избежать ошибок при отсутствии массива, в этом выражении используется оператор `?`.

`@triggerBody()?['<array-name>']` 

<a name="if-action"></a>

### <a name="if-action"></a>Действие If

Это действие, которое является *условным оператором*, оценивает выражение, которое представляет условие и запускает другую ветвь, основанную на том, является ли условие истинным или ложным. Если условие истинное, ему будет присвоено состояние Succeeded (Успешно). Дополнительные сведения см. в разделе [Создание условных операторов, которые управляют действиями в рабочих процессах Azure Logic Apps](../logic-apps/logic-apps-control-flow-conditional-statement.md).

``` json
"Condition": {
   "type": "If",
   "expression": { "<condition>" },
   "actions": {
      "<action-1>": { "<action-definition>" }
   },
   "else": {
      "actions": {
        "<action-2>": { "<action-definition" }
      }
   },
   "runAfter": {}
}
```

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*condition*> | Объект JSON | Условие, которое может быть выражением, для оценки | 
| <*action-1*> | Объект JSON | Действие выполнится когда <*condition*> будет истинное | 
| <*action-definition*> | Объект JSON | Определение действия | 
| <*action-2*> | Объект JSON | Действие выполнится когда <*condition*> будет ложным | 
|||| 

Действия в объектах `actions` или `else` получают следующие статусы.

* "Succeeded", если они запускаются и выполняются успешно;
* "Failed", если они запускаются, но завершаются ошибкой;
* "Skipped", если не запускается соответствующая ветвь.

*Пример*

Это условие указывает, что когда целочисленная переменная имеет значение больше нуля, рабочий процесс проверяет веб-сайт. Если переменная равна нулю или меньше, рабочий процесс проверяет другой веб-сайт.

```json
"Condition": {
   "type": "If",
   "expression": {
      "and": [ {
         "greater": [ "@variables('myIntegerVariable')", 0 ] 
      } ]
   },
   "actions": { 
      "HTTP - Check this website": {
         "type": "Http",
         "inputs": {
         "method": "GET",
            "uri": "http://this-url"
         },
         "runAfter": {}
      }
   },
   "else": {
      "actions": {
         "HTTP - Check this other website": {
            "type": "Http",
            "inputs": {
               "method": "GET",
               "uri": "http://this-other-url"
            },
            "runAfter": {}
         }
      }
   },
   "runAfter": {}
}
```  

#### <a name="how-conditions-use-expressions"></a>Использование выражений условиями

Ниже приведены некоторые примеры, показывающие, как можно использовать выражения в условиях.
  
| JSON | Результат | 
|------|--------| 
| expression: @parameters('<*hasSpecialAction*>') | Только для логических выражений условие передается для любого истинного значения. <p>Чтобы преобразовать другие типы в логический, используйте следующие функции: `empty()` или `equals()`. | 
| expression: @greater(actions('<*action*>').output.value, parameters('<*threshold*>')) | Для сравнения функций действие выполняется только тогда, когда результат <*action*> больше значения <*threshold*>. | 
| expression: @or(greater(actions('<*action*>').output.value, parameters('<*threshold*>')), less(actions('<*same-action*>').output.value, 100)) | Для логических функций и создания вложенных логических выражений действие выполняется, когда результат <*action*> больше значения <*threshold*> или меньше 100. | 
| expression: @equals(length(actions('<*action*>').outputs.errors), 0)) | Можно использовать функции массива для проверки того, имеет ли массив какие-либо элементы. Действие выполняется, если массив `errors` пустой. | 
||| 

<a name="scope-action"></a>

### <a name="scope-action"></a>Действие scope

Логические группы этого действия в *областях*, которые получают свое состояние после завершения действий в той области. Затем можно использовать статус области, чтобы определить, выполняются ли другие действия. Дополнительные сведения см. в разделе [Создание областей, которые выполняют действия рабочего процесса на основе состояния группы в Azure Logic Apps](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md).

```json
"Scope": {
   "type": "Scope",
   "actions": {
      "<inner-action-1>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      },
      "<inner-action-2>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      }
   }
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------|  
| <*inner-action-1...n*> | Объект JSON | Одно или несколько действий, которые выполняются в области |
| <*action-inputs*> | Объект JSON | Входные данные для каждого действия |
|||| 

<a name="switch-action"></a>

### <a name="switch-action"></a>Действие switch

Это действие, также известное как *оператор switch*, организует другие действия по *случаях* и присваивает значение каждому случаю, за исключением случая по умолчанию, если он существует. Когда выполняется рабочий процесс, действие **Переключить** сравнивает значение из выражения, объекта или токена со значениями, указанными для каждого случая. Если действие **Переключить** находит соответствующий вариант, рабочий процесс выполняет действия только для этого варианта. Каждый раз, когда действие **Переключить** запускается, существует только один подходящий случай или совпадений нет. Если совпадений не существует, действие **Переключить** выполняется по умолчанию. Дополнительные сведения см. в разделе [Создание операторов switch, которые запускают действия рабочего процесса на основе определенных значений в Azure Logic Apps](../logic-apps/logic-apps-control-flow-switch-statement.md).

``` json
"Switch": {
   "type": "Switch",
   "expression": "<expression-object-or-token>",
   "cases": {
      "Case": {
         "actions": {
           "<action-name>": { "<action-definition>" }
         },
         "case": "<matching-value>"
      },
      "Case_2": {
         "actions": {
           "<action-name>": { "<action-definition>" }
         },
         "case": "<matching-value>"
      }
   },
   "default": {
      "actions": {
         "<default-action-name>": { "<default-action-definition>" }
      }
   },
   "runAfter": {}
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*expression-object-or-token*> | Varies | Выражение, объект JSON или маркер безопасности для оценки | 
| <*action-name*> | Строка | Имя действия для запуска в случае соответствия | 
| <*action-definition*> | Объект JSON | Определение действия для запуска в случае соответствия | 
| <*matching-value*> | Varies | Значение для сравнения с результатом вычисления | 
|||| 

*Необязательно.*

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*default-action-name*> | Строка | Имя действия по умолчанию для запуска, если не существует подходящего случая | 
| <*default-action-definition*> | Объект JSON | Определение действия по умолчанию для запуска, если не существует подходящего случая | 
|||| 

*Пример*

Это определение действия оценивает, выбирает ли пользователь в ответ на письмо с запросом вариант "Утвердить" или "Отклонить". Исходя из этого выбора, действие **Переключить** запускает действия для случая сопоставления, который должен отправить другое электронное сообщение ответчику, но с разными формулировками в каждом случае. 

``` json
"Switch": {
   "type": "Switch",
   "expression": "@body('Send_approval_email')?['SelectedOption']",
   "cases": {
      "Case": {
         "actions": {
            "Send_an_email": { 
               "type": "ApiConnection",
               "inputs": {
                  "Body": "Thank you for your approval.",
                  "Subject": "Response received", 
                  "To": "Sophie.Owen@contoso.com"
               },
               "host": {
                  "connection": {
                     "name": "@parameters('$connections')['office365']['connectionId']"
                  }
               },
               "method": "post",
               "path": "/Mail"
            },
            "runAfter": {}
         },
         "case": "Approve"
      },
      "Case_2": {
         "actions": {
            "Send_an_email_2": { 
               "type": "ApiConnection",
               "inputs": {
                  "Body": "Thank you for your response.",
                  "Subject": "Response received", 
                  "To": "Sophie.Owen@contoso.com"
               },
               "host": {
                  "connection": {
                     "name": "@parameters('$connections')['office365']['connectionId']"
                  }
               },
               "method": "post",
               "path": "/Mail"
            },
            "runAfter": {}     
         },
         "case": "Reject"
      }
   },
   "default": {
      "actions": { 
         "Send_an_email_3": { 
            "type": "ApiConnection",
            "inputs": {
               "Body": "Please respond with either 'Approve' or 'Reject'.",
               "Subject": "Please respond", 
               "To": "Sophie.Owen@contoso.com"
            },
            "host": {
               "connection": {
                  "name": "@parameters('$connections')['office365']['connectionId']"
               }
            },
            "method": "post",
            "path": "/Mail"
         },
         "runAfter": {} 
      }
   },
   "runAfter": {
      "Send_approval_email": [ 
         "Succeeded"
      ]
   }
}
```

<a name="until-action"></a>

### <a name="until-action"></a>Действие Until

Это действие цикла содержит действия, которые выполняются, пока указанное условие имеет истинное значение. После завершения работы всех других действий на последнем этапе цикл проверяет условие. Можно включить несколько действий в объект `"actions"`, и действие должно определить как минимум одно ограничение. Дополнительные сведения см. в разделе [Цикл until](../logic-apps/logic-apps-control-flow-loops.md#until-loop). 

```json
 "Until": {
   "type": "Until",
   "actions": {
      "<action-name>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      },
      "<action-name>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      }
   },
   "expression": "<condition>",
   "limit": {
      "count": <loop-count>,
      "timeout": "<loop-timeout>"
   },
   "runAfter": {}
}
```

| Значение | type | ОПИСАНИЕ | 
|-------|------|-------------| 
| <*action-name*> | Строка | Имя действия, которое необходимо выполнить внутри цикла | 
| <*action-type*> | Строка | Тип действия, которое необходимо запустить | 
| <*action-inputs*> | Различные | Входные данные для выполнения действия | 
| <*condition*> | Строка | Условие или выражение для оценки после всех действий в завершении цикла | 
| <*loop-count*> | Целое число  | Предел максимального количества циклов, которое может выполнить действие. Значение `count` по умолчанию — 60. | 
| <*loop-timeout*> | Строка | Предел времени работы цикла, в течение которого цикл может работать. Значение `timeout` по умолчанию равно `PT1H`, которое требует [формат ISO 8601](https://en.wikipedia.org/wiki/ISO_8601). |
|||| 

*Пример*

Это определение действия цикла отправляет HTTP-запрос по указанному URL-адресу до тех пор, пока не будет выполнено одно из этих условий. 

* Запрос возвращает ответ с состоянием кода "200 OK".
* Цикл выполнялся 60 раз.
* Цикл был выполнен в течение одного часа.

```json
 "Run_until_loop_succeeds_or_expires": {
    "type": "Until",
    "actions": {
        "Http": {
            "type": "Http",
            "inputs": {
                "method": "GET",
                "uri": "http://myurl"
            },
            "runAfter": {}
        }
    },
    "expression": "@equals(outputs('Http')['statusCode', 200])",
    "limit": {
        "count": 60,
        "timeout": "PT1H"
    },
    "runAfter": {}
}
```

<a name="subscribe-unsubscribe"></a>

## <a name="webhooks-and-subscriptions"></a>Веб-перехватчики и подписки

Триггеры и действия на основе веб-перехватчика не регулярно проверяют конечные точки, но ждут конкретных событий или данных на этих конечных точках. Эти триггеры и действия *подписываются* на конечные точки, предоставляя *URL-адрес обратного вызова*, куда конечная точка может отправлять ответы.

Вызов `subscribe` выполняется при любом изменении рабочего процесса, например когда происходит обновление учетных данных или изменяются входные параметры для триггера или действия. Этот вызов использует те же параметры, что и стандартные действия HTTP. 

Вызов `unsubscribe` выполняется автоматически, когда при выполнении операции триггер или действие становится недопустимым, например:

* удаление или отключение триггера; 
* удаление или отключение рабочего процесса; 
* удаление или отключение подписки. 

Для поддержки этих вызовов выражение `@listCallbackUrl()` возвращает уникальный "URL-адрес обратного вызова" для этого триггера или действия. Этот URL-адрес представляет собой уникальный идентификатор для конечных точек, использующих REST API службы. Параметры этой функции совпадают с параметрами триггера веб-перехватчика или действия.

<a name="asynchronous-limits"></a>

## <a name="change-asynchronous-duration"></a>Изменение асинхронной длительности

Для триггеров и действий можно ограничить длительность для асинхронного шаблона определенным интервалом времени, добавив свойство `limit.timeout`. Таким образом, если действие не закончилось, когда интервал истекает, статус действия помечается `Cancelled` с кодом `ActionTimedOut`. Свойство `timeout` использует [формат ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). 

``` json
"<trigger-or-action-name>": {
   "type": "Workflow | Webhook | Http | ApiConnectionWebhook | ApiConnection",
   "inputs": {},
   "limit": {
      "timeout": "PT10S"
   },
   "runAfter": {}
}
```

<a name="runtime-config-options"></a>

## <a name="runtime-configuration-settings"></a>Параметры конфигурации среды выполнения

Вы можете изменить поведение среды выполнения по умолчанию для триггеров и действий с этими свойствами `runtimeConfiguration` в триггере или определении действия.

| Свойство | type | ОПИСАНИЕ | Триггер или действие | 
|----------|------|-------------|-------------------| 
| `runtimeConfiguration.concurrency.runs` | Целое число  | Измените [*Предел по умолчанию*](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) количества экземпляров приложений логики, которые могут выполняться одновременно или в параллельном режиме. Это значение помогает ограничить количество запросов, которые получают серверные системы. <p>Параметр свойства `runs`, равный `1`, работает так же, как параметр свойства `operationOptions`, равный `SingleInstance`. Можно установить любое свойство, но не оба сразу. <p>Дополнительные сведения об изменении предела по умолчанию см. в раздел об [изменении параллелизма триггера](#change-trigger-concurrency) или о [последовательном запуске экземпляров](#sequential-trigger). | Все триггеры | 
| `runtimeConfiguration.concurrency.maximumWaitingRuns` | Целое число  | Измените [*Предел по умолчанию*](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) количества экземпляров приложений логики, ожидающих выполнения, когда приложение логики уже выполняет максимальное число параллельных экземпляров. Можно изменить такое ограничение параллелизма в свойстве `concurrency.runs`. <p>Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | Все триггеры | 
| `runtimeConfiguration.concurrency.repetitions` | Целое число  | Изменение [*предела по умолчанию*](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) количества итераций цикла Foreach, которые могут выполняться одновременно или в параллельном режиме. <p>Параметр свойства `repetitions`, равный `1`, работает так же, как параметр свойства `operationOptions`, равный `SingleInstance`. Можно установить любое свойство, но не оба сразу. <p>Дополнительные сведения об изменении предела по умолчанию см. в разделе [Изменение параллелизма цикла Foreach](#change-for-each-concurrency) или [Последовательный запуск циклов Foreach](#sequential-for-each). | Действие: <p>[Foreach](#foreach-action) | 
||||| 

<a name="operation-options"></a>

## <a name="operation-options"></a>Варианты операций

Можно изменить поведение по умолчанию для триггеров и действий со свойством `operationOptions` в триггере или определении действия.

| Параметр операции | type | ОПИСАНИЕ | Триггер или действие | 
|------------------|------|-------------|-------------------| 
| `DisableAsyncPattern` | Строка | Запускайте действия на основе HTTP синхронно, а не асинхронно. <p><p>Чтобы задать этот параметр, см. в разделе [Синхронное выполнение действия](#asynchronous-patterns). | Действия: <p>[ApiConnection](#apiconnection-action), <br>[HTTP](#http-action), <br>[Ответ](#response-action) | 
| `OptimizedForHighThroughput` | Строка | Изменение [предела по умолчанию](../logic-apps/logic-apps-limits-and-config.md#throughput-limits) количества выполненных действий за 5 минут до [максимального предела](../logic-apps/logic-apps-limits-and-config.md#throughput-limits). <p><p>Чтобы задать этот параметр, см. в разделе [Запуск в режиме высокой пропускной способности](#run-high-throughput-mode). | Все действия | 
| `Sequential` | Строка | Запускайте итерации цикла Foreach по одной, а не одновременно параллельно. <p>Этот параметр работает так же, как параметр свойства `runtimeConfiguration.concurrency.repetitions`, равный `1`. Можно установить любое свойство, но не оба сразу. <p><p>Дополнительные сведения о задании этого параметра см. в разделе [Последовательный запуск циклов Foreach](#sequential-for-each).| Действие: <p>[Foreach](#foreach-action) | 
| `SingleInstance` | Строка | Запустите триггер для каждого экземпляра приложения логики последовательно и дождитесь завершения предыдущего активного запуска, прежде чем запускать следующий экземпляр приложения логики. <p><p>Этот параметр работает так же, как параметр свойства `runtimeConfiguration.concurrency.runs`, равный `1`. Можно установить любое свойство, но не оба сразу. <p>Чтобы задать этот параметр, см. раздел [Последовательная активизация экземпляров](#sequential-trigger). | Все триггеры | 
||||

<a name="change-trigger-concurrency"></a>

### <a name="change-trigger-concurrency"></a>Изменение параллелизма триггера

По умолчанию экземпляры приложения логики запускаются одновременно или параллельно до [предела по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Таким образом, каждый экземпляр триггера запускается до того, как закончится запуск активного экземпляра активного приложения логики. Это ограничение помогает контролировать количество запросов, которые получают серверные системы. 

Чтобы изменить предел по умолчанию, можно использовать либо редактор просмотра кода, либо Конструктор Logic Apps, поскольку изменение параметра параллелизма с помощью конструктора добавляет или обновляет свойство `runtimeConfiguration.concurrency.runs` в базовом определении триггера и наоборот. Это свойство определяет максимальное число экземпляров приложения логики, которые могут выполняться параллельно. 

> [!NOTE] 
> Если вы настроите триггер для запуска последовательно с помощью конструктора или редактора представления кода, не устанавливайте свойство `operationOptions`триггера равное `SingleInstance` в редакторе представления кода. В противном случае возникнет ошибка проверки. Дополнительные сведения см. в разделе [Последовательная активизация экземпляров](#sequential-trigger).

#### <a name="edit-in-code-view"></a>Изменение в представлении кода 

В базовом определение триггера добавьте или обновите значение `runtimeConfiguration.concurrency.runs` между `1` и `50` включительно.

Ниже приведен пример, который ограничивает параллельные выполнения до 10 экземпляров.

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": 10
      }
   }
}
```

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В правом верхнем углу окна триггера нажмите кнопку с многоточием (...) и выберите **Параметры**.

2. В разделе **Управление параллелизмом** установите параметру **Переопределить значения по умолчанию** значение **Вкл.** 

3. Перетащите ползунок **Степень параллелизма** к необходимому значению. 

<a name="change-for-each-concurrency"></a>

### <a name="change-for-each-concurrency"></a>Изменение параллелизма цикла Foreach

По умолчанию итерации цикла Foreach запускаются одновременно или параллельно до [предела по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, можно использовать либо редактор просмотра кода, либо Конструктор Logic Apps, поскольку изменение параметра параллелизма с помощью конструктора добавляет или обновляет свойство `runtimeConfiguration.concurrency.repetitions` в базовом определении действия Foreach и наоборот. Это свойство определяет максимальное число итераций, которые могут выполняться параллельно.

> [!NOTE] 
> Если вы установите действие Foreach для запуска последовательно с помощью конструктора или редактора представления кода, не устанавливайте свойство `operationOptions` действия равное `Sequential` в редакторе представления кода. В противном случае возникнет ошибка проверки. Дополнительные сведения см. в разделе [Последовательный запуск циклов Foreach](#sequential-for-each).

#### <a name="edit-in-code-view"></a>Изменение в представлении кода 

В базовом определение действия Foreach добавьте или обновите значение `runtimeConfiguration.concurrency.repetitions` между `1` и `50` включительно. 

Ниже приведен пример, который ограничивает параллельные выполнения до 10 итераций.

```json
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": 10
      }
   }
}
```

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В правом верхнем углу в окне действия **Foreach** нажмите кнопку с многоточием (...), а затем выберите **Параметры**.

2. В разделе **Управление параллелизмом** установите параметру **Переопределить значения по умолчанию** значение **Вкл.** 

3. Перетащите ползунок **Степень параллелизма** к необходимому значению. 

<a name="change-waiting-runs"></a>

### <a name="change-waiting-runs-limit"></a>Изменение предела ожидающих запусков

По умолчанию экземпляры приложения логики запускаются одновременно или параллельно до [предела по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Каждый экземпляр триггера запускается перед завершением работы ранее активного экземпляра приложения логики. Несмотря на то что можно [изменить этот предел по умолчанию](#change-trigger-concurrency), когда число экземпляров приложения логики достигает нового предела параллелизма, все новые экземпляры должны ожидать выполнения. 

Число ожидающих запусков также имеет [предел по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits), который можно изменить. Однако после того, как приложение логики достигнет предела в ожиданиях, модуль Logic Apps больше не принимает новые запуски. Триггеры запроса и веб-перехватчика возвращают 429 ошибку, а повторяющиеся триггеры начинают пропускать попытки опроса.

Чтобы изменить предел по умолчанию при запусках ожидания, в базовом определении триггера добавьте и задайте значение `runtimeConfiguration.concurency.maximumWaitingRuns` между `0` и `100`. 

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "maximumWaitingRuns": 50
      }
   }
}
```

<a name="sequential-trigger"></a>

### <a name="trigger-instances-sequentially"></a>Последовательная активация экземпляров

Чтобы запустить каждый экземпляр приложения логики только после завершения предыдущего экземпляра, установите триггер для последовательного запуска. Вы можете использовать либо редактор просмотра кода, либо конструктор Logic Apps, поскольку изменение параметра параллелизма с помощью конструктора также добавляет или обновляет свойство `runtimeConfiguration.concurrency.runs` в базовом определении триггера и наоборот. 

> [!NOTE] 
> Если вы настроите триггер для последовательного запуска с помощью конструктора или редактора представления кода, не устанавливайте свойство `operationOptions` триггера равное `Sequential` в редакторе представления кода. В противном случае возникнет ошибка проверки. 

#### <a name="edit-in-code-view"></a>Изменение в представлении кода

В определении триггера задайте одно из этих свойств, но не оба. 

Задайте для свойства `runtimeConfiguration.concurrency.runs` значение `1`.

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": 1
      }
   }
}
```

*–или–*

Задайте для свойства `operationOptions` значение `SingleInstance`.

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "operationOptions": "SingleInstance"
}
```

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В правом верхнем углу окна триггера нажмите кнопку с многоточием (...) и выберите **Параметры**.

2. В разделе **Управление параллелизмом** установите параметру **Переопределить значения по умолчанию** значение **Вкл.** 

3. Перетащите ползунок **Степень параллелизма** на номер `1`. 

<a name="sequential-for-each"></a>

### <a name="run-for-each-loops-sequentially"></a>Последовательный запуск циклов Foreach

Чтобы запустить итерацию цикла Foreach только после завершения предыдущей итерации, настройте последовательное выполнение каждого действия. Вы можете использовать либо редактор просмотра кода, либо конструктор Logic Apps, поскольку изменение действия параллелизма с помощью конструктора также добавляет или обновляет свойство `runtimeConfiguration.concurrency.repetitions` в базовом определении действия и наоборот. 

> [!NOTE] 
> Если вы настроите последовательное выполнение действия Foreach для запуска с помощью конструктора или редактора представления кода, не устанавливайте свойство `operationOptions` действия равным `Sequential` в редакторе представления кода. В противном случае возникнет ошибка проверки. 

#### <a name="edit-in-code-view"></a>Изменение в представлении кода

В определении действия задайте один из этих свойств, но не оба. 

Задайте для свойства `runtimeConfiguration.concurrency.repetitions` значение `1`.

```json
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": 1
      }
   }
}
```

*–или–*

Задайте для свойства `operationOptions` значение `Sequential`.

```json
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "operationOptions": "Sequential"
}
```

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В правом верхнем углу в окне действия **Foreach** нажмите кнопку с многоточием (...), а затем выберите **Параметры**.

2. В разделе **Управление параллелизмом** установите параметру **Переопределить значения по умолчанию** значение **Вкл.** 

3. Перетащите ползунок **Степень параллелизма** на номер `1`. 

<a name="asynchronous-patterns"></a>

### <a name="run-actions-synchronously"></a>Синхронное выполнение действий

По умолчанию все действия на основе HTTP следуют стандартной модели асинхронных операций. Этот шаблон указывает, что когда действие на основе HTTP отправляет запрос на указанную конечную точку, удаленный сервер отправляет ответ "202 ACCEPTED". Этот ответ означает, что сервер принял запрос на обработку. Модуль Logic Apps продолжает проверять URL, указанный в заголовке местоположения ответа до тех пор, пока обработка не прекратится, что является ответом, отличным от 202.

Тем не менее у запросов есть ограничение по времени ожидания, поэтому для длительных действий можно отключить асинхронное поведение, добавив и установив свойство `operationOptions` в `DisableAsyncPattern` под входами действия.
  
```json
"<some-long-running-action>": {
   "type": "Http",
   "inputs": { "<action-inputs>" },
   "operationOptions": "DisableAsyncPattern",
   "runAfter": {}
}
```

<a name="run-high-throughput-mode"></a>

### <a name="run-in-high-throughput-mode"></a>Запуск в режиме высокой пропускной способности

Для запуска одного приложения логики количество действий, выполняемых каждые 5 минут, имеет [предел по умолчанию](../logic-apps/logic-apps-limits-and-config.md#throughput-limits). Чтобы повысить этот предел до [максимума](../logic-apps/logic-apps-limits-and-config.md#throughput-limits), установите для свойства `operationOptions` значение `OptimizedForHighThroughput`. Этот параметр помещает приложение логики в режим высокой пропускной способности. 

> [!NOTE]
> Режим высокой пропускной способности доступен в предварительной версии. Вы можете также распределить рабочую нагрузку между несколькими приложениями логики.

```json
"<action-name>": {
   "type": "<action-type>",
   "inputs": { "<action-inputs>" },
   "operationOptions": "OptimizedForHighThroughput",
   "runAfter": {}
}
```

## <a name="next-steps"></a>Дополнительная информация

* См. дополнительные сведения о [языке определения рабочего процесса](../logic-apps/logic-apps-workflow-definition-language.md)
