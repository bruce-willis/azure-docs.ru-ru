---
title: Семантическая интерпретация в API службы поиска и распознавания данных | Документация Майкрософт
description: Узнайте, как использовать семантическую интерпретацию в API службы поиска и распознавания данных (KES) в Cognitive Services.
services: cognitive-services
author: bojunehsu
manager: stesp
ms.service: cognitive-services
ms.component: knowledge-exploration
ms.topic: article
ms.date: 03/26/2016
ms.author: paulhsu
ms.openlocfilehash: 022188464eb7269b69f96a058b444167b587387c
ms.sourcegitcommit: 95d9a6acf29405a533db943b1688612980374272
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2018
ms.locfileid: "35380297"
---
# <a name="semantic-interpretation"></a>Семантическая интерпретация
Семантическая интерпретация позволяет связать семантические выходные данные с каждым интерпретируемым путем с помощью грамматики.  В частности, эта служба оценивает последовательность операторов в элементах `tag`, проверяемых при интерпретации для вычисления конечного результата.  

Инструкция может быть назначением литерала или переменной к другой переменной.  Она также может назначать переменной выходные данные функции с 0 или большим числом параметров.  Каждый параметр функции можно указать с помощью литерала или переменной.  Если функция не возвращает никаких выходных данных, то назначение пропускается.

```xml
<tag>x = 1; y = x;</tag>
<tag>q = All(); q = And(q, q2);</tag>
<tag>AssertEquals(x, 1);</tag>
```

Переменная задается с помощью идентификатора имени, который начинается с буквы и содержит только буквы (A-Z), цифры (0-9) и символ подчеркивания (\_).  Ее тип неявно выводится на основании литерала или назначенного выходного значения функции. 

Ниже приведен текущий список поддерживаемых типов данных.

|type|ОПИСАНИЕ|Примеры|
|----|----|----|
|Строка|Последовательность, содержащая 0 или более знаков.|"Hello World!"<br/>""|
|Bool|Логическое значение.|Да<br/>false|
|Int32|32-разрядное целое число со знаком.  –2,1e9…2,1e9|123<br/>–321|
|Int64|64-разрядное целое число со знаком. -9,2e18 и 9,2e18|9 876 543 210|
|Double|Число с плавающей запятой двойной точности. 1,7e+/-308 (15 разрядов)|123,456789<br/>1,23456789e2|
|Guid|Глобальный уникальный идентификатор|"602DD052-CC47-4B23-A16A-26B52D30C05B"|
|Запрос|Выражение запроса, которое определяет подмножество объектов данных в индексе.|All()<br/>And(*q1*, *q2*)|

<a name="semantic-functions"></a>
## <a name="semantic-functions"></a>Семантические функции
Имеется набор встроенных семантических функций.  Они позволяют создавать сложные запросы и предоставляют контекстное управление интерпретациями грамматики.

### <a name="and-function"></a>Функция And
`query = And(query1, query2);`

Возвращает запрос, содержащий область пересечения двух входных запросов.

### <a name="or-function"></a>Функция Or
`query = Or(query1, query2);`

Возвращает запрос, содержащий область объединения двух входных запросов.

### <a name="all-function"></a>Функция All
`query = All();`

Возвращает запрос, включающий в себя все объекты данных.

В следующем примере функция All() используется для итеративного создания запроса на основании области пересечения 1 или нескольких ключевых слов.

```
<tag>query = All();</tag>
<item repeat="1-">
  <attrref uri="academic#Keyword" name="keyword">
  <tag>query = And(query, keyword);</tag>
</item>
```

### <a name="none-function"></a>Функция None
`query = None();`

Возвращает запрос, не включающий в себя объекты данных.

В следующем примере функция None() используется для итеративного создания запроса на основании области объединения 1 или нескольких ключевых слов.

```
<tag>query = None();</tag>
<item repeat="1-">
  <attrref uri="academic#Keyword" name="keyword">
  <tag>query = Or(query, keyword);</tag>
</item>
```

### <a name="query-function"></a>Функция Query
```
query = Query(attrName, value)
query = Query(attrName, value, op)
```

Возвращает запрос, включающий в себя только объекты данных, атрибут *attrName* которых соответствует значению *value* в соответствии с указанной операцией *op*, которой по умолчанию является операция "eq".  Как правило, элемент `attrref` используется для создания запроса на основе соответствующей строки входного запроса.  Если значение задано или получено другим способом, функция Query() может использоваться для создания запроса, соответствующего этому значению.

В следующем примере функция Query() используется, чтобы реализовать поддержку указания научных публикаций за определенное десятилетие.

```xml
written in the 90s
<tag>
  beginYear = Query("academic#Year", 1990, "ge");
  endYear = Query("academic#Year", 2000, "lt");
  year = And(beginYear, endYear);
</tag>
```

<a name="composite-function"/>
### <a name="composite-function"></a>Функция Composite
`query = Composite(innerQuery);`

Возвращает запрос, который инкапсулирует запрос *innerQuery*, состоящий соответствующих вложенных атрибутов общего составного атрибута *attr*.  Для инкапсуляции требуется, чтобы составной атрибут *attr* любого соответствующего объекта данных имел по крайней мере одно значение, которое удовлетворяет внутреннему запросу *innerQuery*.  Обратите внимание на то, что запрос вложенных атрибутов составного атрибута должно быть инкапсулировано с помощью функции Composite(), прежде чем его можно будет объединить с другими запросами.

Например, следующий запрос возвращает научные публикации Гарри Шама (Harry Shum) за период, когда он работал в корпорации Майкрософт.
```
Composite(And(Query("academic#Author.Name", "harry shum"), 
              Query("academic#Author.Affiliation", "microsoft")));
```

С другой стороны, приведенный ниже запрос возвращает научные публикации, одним из авторов которых является Гарри Шам (Harry Shum) и которые относятся к корпорации Майкрософт.
```
And(Composite(Query("academic#Author.Name", "harry shum"), 
    Composite(Query("academic#Author.Affiliation", "microsoft")));
```

### <a name="getvariable-function"></a>Функция GetVariable
`value = GetVariable(name, scope);`

Возвращает значение переменной *name*, определенной в указанной области *scope*.  Параметр *name* — это идентификатор, который начинается с буквы и содержит только буквы (A-Z), цифры (0-9) и символ подчеркивания (_).  Параметру *scope* можно присвоить значение "request" или "system".  Обратите внимание на то, что переменные, определенные в разных областях, отличны друг от друга, включая переменные, определенные посредством выходных данных семантических функций.

Переменные области запроса являются общими для всех интерпретаций в текущем запросе interpret.  Их можно использовать для управления поиском интерпретаций в грамматике.

Системные переменные предопределены службой и могут использоваться для получения различных статистических данных о текущем состоянии системы.  Ниже приведен набор поддерживаемых системных переменных.

|ИМЯ|type|ОПИСАНИЕ|
|----|----|----|
|IsAtEndOfQuery|Bool|Имеет значение true, если достигнут конец входного запроса для текущего поиска интерпретаций.|
|IsBeyondEndOfQuery|Bool|Имеет значение true, если для текущего поиска интерпретаций предложены варианты завершения, выходящие за пределы текста входного запроса.|

### <a name="setvariable-function"></a>Функция SetVariable
`SetVariable(name, value, scope);`

Назначает значение *value* переменной *name* в указанной области *область*.  Параметр *name* — это идентификатор, который начинается с буквы и содержит только буквы (A-Z), цифры (0-9) и символ подчеркивания (_).  В настоящее время для *scope* поддерживается только значение "request".  Системные переменные, которые можно задать, отсутствуют.

Переменные области запроса являются общими для всех интерпретаций в текущем запросе interpret.  Их можно использовать для управления поиском интерпретаций в грамматике.

### <a name="assertequals-function"></a>Функция AssertEquals
`AssertEquals(value1, value2);`

Если значения *value1* и *value1* равны, выполнение функции завершается успешно и не имеет побочных эффектов.  В противном случае функция завершается ошибкой и отклоняет интерпретацию.

### <a name="assertnotequals-function"></a>Функция AssertNotEquals
`AssertNotEquals(value1, value2);`

Если значения *value1* и *value1* не равны, выполнение функции завершается успешно и не имеет побочных эффектов.  В противном случае функция завершается ошибкой и отклоняет интерпретацию.


