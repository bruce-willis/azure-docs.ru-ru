---
title: Типы сущностей в приложениях LUIS — Интеллектуальная служба распознавания речи
titleSuffix: Azure Cognitive Services
description: Добавляйте сущности (ключевые данные в предметной области приложения) в приложения Интеллектуальной службы распознавания речи (LUIS).
services: cognitive-services
author: diberry
manager: cgronlun
ms.service: cognitive-services
ms.component: language-understanding
ms.topic: article
ms.date: 09/10/2018
ms.author: diberry
ms.openlocfilehash: 3ed10ac428b7ce2e528ccf46e34c1d394523bdec
ms.sourcegitcommit: 4ecc62198f299fc215c49e38bca81f7eb62cdef3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2018
ms.locfileid: "47042454"
---
# <a name="entities-in-luis"></a>Сущности в LUIS

Сущности — это слова или фразы в высказываниях, которые являются ключевыми данными в предметной области приложения.

## <a name="entity-compared-to-intent"></a>Сущность по сравнению с намерением
Сущность представляет подлежащее извлечению слово или фразу в высказывании. Фраза может содержать много сущностей или вообще ни одной. Сущность представляет класс, включающий коллекцию похожих объектов (мест, предметов, людей, событий или понятий). Сущности описывают информацию, относящуюся к намерению, и иногда они необходимы приложению для выполнения поставленной задачи. Например, в приложение для поиска новостей могут входить такие сущности, как "topic", "source", "keyword" и "publishing date", которые являются ключевыми данными для поиска новостей. В приложении для путешествий с функциями бронирования сущности "location", "date", "airline", "travel class" и "tickets" представляют собой ключевые данные для бронирования авиабилетов (связанные с намерением "Bookflight").

Если сравнивать, намерение представляет предсказание всего высказывания. 

## <a name="entities-represent-data"></a>Сущности представляют данные
Сущности — это данные, которые требуется извлечь из высказывания. Это может быть имя, дата, название продукта или любая группа слов. 

|Фраза|Сущность|Данные|
|--|--|--|
|Купить 3 билета в Нью-Йорк|Предварительно созданная сущность number<br>Location.Destination|3<br>Нью-Йорк|
|Купить билет из Нью-Йорка в Лондон на 5 марта|Location.Origin<br>Location.Destination<br>Предварительно созданная сущность datetimeV2|Нью-Йорк<br>Лондон<br>5 марта 2018 г.|

## <a name="entities-are-optional-but-highly-recommended"></a>Сущности являются необязательными, но настоятельно рекомендуемыми к использованию
Тогда как намерения являются обязательными, использовать сущности необязательно. Не нужно создавать сущности для каждого понятия в приложении — они требуются только для тех, которые требуются для работы приложения. 

Если высказывания не содержат сведения, необходимые боту для продолжения, добавлять их не нужно. Их можно добавить позднее по мере развития приложения. 

Если вы не знаете, как будете использовать данные, добавьте несколько общих предварительно созданных сущностей, таких как datetimeV2, порядковый номер, адрес электронной почты и номер телефона.

## <a name="label-for-word-meaning"></a>Пометка для значения слова
Если выбор или расположение слов одинаковы, но имеют разное значение, их не нужно помечать с помощью сущности. 

В следующих высказываниях слово `fair` является омографом. Оно пишется одинаково, но имеет другое значение:

|Фраза|
|--|
|Какие ярмарки проходят неподалеку от Сиэтла этим летом?|
|Справедлива ли эта оценка за обзор Сиэтла?|

Если требуется, чтобы сущность события находила все данные события, пометьте слово `fair` в первом высказывании, а не во втором.

## <a name="entities-are-shared-across-intents"></a>Сущности являются общими в намерениях
Сущности являются общими в намерениях. Они не принадлежат отдельному намерению. Намерения и сущности могут быть семантически связаны, но эта связь не является исключительной.

Во фразе "Book me a ticket to Paris" "Paris" — это сущность типа расположения. Распознавая сущности, которые упоминаются во входных данных пользователя, LUIS помогает выбирать конкретные действия, выполняемые для удовлетворения намерения.

## <a name="assign-entities-in-none-intent"></a>Назначение сущностей в намерении None
Все намерения, включая намерение **None**, должны иметь помеченные сущности. В этом случае LUIS хорошо известно о месте расположения сущностей в высказываниях и какие слова находятся вокруг сущностей. 

## <a name="types-of-entities"></a>Типы сущностей
LUIS предлагает множество типов сущностей — предварительно созданные сущности, настраиваемые обученные сущности и сущности списка.

| ИМЯ | Можно пометить | ОПИСАНИЕ |
| -- |--|--|
| **Предварительно созданная** <br/>[Настраиваемая](#prebuilt)| |  **Определение**<br>Встроенные типы, представляющие общие понятия. <br><br>**Список**<br/>число ключевых фраз, порядковый номер, температура, измерение, деньги, возраст, процент, адрес электронной почты, URL-адрес, номер телефона и ключевая фраза. <br><br>Имена предварительно созданных сущностей являются зарезервированными. <br><br>Все предварительно созданные сущности, добавленные в приложение, возвращаются в запросе [конечной точки](luis-glossary.md#endpoint). Дополнительные сведения см. в статье о [предварительно созданных сущностях](./luis-prebuilt-entities.md). <br/><br/>[Пример ответа для сущности](luis-concept-data-extraction.md#prebuilt-entity-data)|
|<!-- added week of 3/21/08 --> **Регулярное выражение**<br/>[RegEx](#regex)||**Определение**<br>Настраиваемое регулярное выражение для форматированного необработанного текста высказывания. Оно не учитывает регистр и игнорирует региональный алфавит.  <br><br>Эта сущность оптимально подходит для слов или фраз, которые согласованно отформатированы с любыми также согласованными вариантами.<br><br>Сопоставление регулярных выражений применяется после внесения изменений при проверке орфографии. <br><br>Если регулярное выражение слишком сложное, например в нем используется много квадратных скобок, вы не сможете добавить выражение в модель. <br><br>**Пример**<br>`kb[0-9]{6,}` соответствует kb123456.<br/><br/>[Краткое руководство](luis-quickstart-intents-regex-entity.md)<br>[Пример ответа для сущности](luis-concept-data-extraction.md)|
| **Простота** <br/>[Прошедшая машинное обучение](#machine-learned) | ✔ | **Определение**<br>Простая сущность — это универсальная сущность, описывающая одно понятие и обучаемая на основе контекста машинного обучения. К контексту относятся выбор слов, размещение слов и длина высказывания.<br/><br/>Это подходящая сущность для слов или фраз, не имеющих согласованного форматирования, но означающих одно и то же. <br/><br/>[Краткое руководство](luis-quickstart-primary-and-secondary-data.md)<br/>[Пример ответа для сущности](luis-concept-data-extraction.md#simple-entity-data)|  
| **Список** <br/>[Точное соответствие](#exact-match)|| **Определение**<br>Сущности списка представляют фиксированный, закрытый набор связанных слов вместе с их синонимами в системе. <br><br>Каждая сущность списка может иметь одну или несколько форм. Она лучше всего подходит для известного набора вариантов для представления одного понятия.<br/><br/>LUIS не обнаруживает дополнительные значения для сущностей списка. Посмотреть предложения для новых слов на основе текущего списка можно с помощью функции **Рекомендовать**.<br/><br>Если имеется несколько сущностей списка с одним и тем же значением, в запросе конечной точки возвращается каждая сущность. <br/><br/>[Краткое руководство](luis-quickstart-intent-and-list-entity.md)<br>[Пример ответа для сущности](luis-concept-data-extraction.md#list-entity-data)| 
| **Pattern.Any** <br/>[Смешанная](#mixed) | ✔|**Определение**<br>Patterns.any — это местозаполнитель переменной длины, используемый только в высказывании шаблона для пометки начала и окончания сущности.  <br><br>**Пример**<br>В высказывании для поиска книг по названию pattern.any извлекает полное название. Высказывание шаблона, использующее pattern.any, — `Who wrote {BookTitle}[?]`.<br/><br/>[Руководство](luis-tutorial-pattern.md)<br>[Пример ответа для сущности](luis-concept-data-extraction.md#composite-entity-data)|  
| **Составная** <br/>[Прошедшая машинное обучение](#machine-learned) | ✔|**Определение**<br>Составная сущность образована из других сущностей, таких как предварительно созданные, простые, регулярное выражение, список, иерархические. Эти отдельные сущности формируют единую сущность. <br><br>**Пример**<br>У составной сущности с именем PlaneTicketOrder могут быть дочерние предварительно созданные сущности `number` и `ToLocation`. <br/><br/>[Руководство](luis-tutorial-composite-entity.md)<br>[Пример ответа для сущности](luis-concept-data-extraction.md#composite-entity-data)|  
| **Иерархическая** <br/>[Прошедшая машинное обучение](#machine-learned) |✔ | **Определение**<br>Иерархическая сущность — это категория контекстно-зависимых обученных простых сущностей.<br><br>**Пример**<br>В иерархической сущности `Location` с дочерними элементами `ToLocation` и `FromLocation` каждый дочерний элемент может быть определен на основе **контекста** в высказывании. В высказывании `Book 2 tickets from Seattle to New York` `ToLocation` и `FromLocation` отличаются в зависимости от контекста на основе окружающих их слов. <br/><br/>**Не следует использовать, если**<br>Если вам нужна сущность с точными текстовыми совпадениями для дочерних элементов вне зависимости от контекста, следует использовать сущность списка. Если вам требуется связь "родитель-потомок" с другими типами сущностей, следует использовать составную сущность.<br/><br/>[Краткое руководство](luis-quickstart-intent-and-hier-entity.md)<br>[Пример ответа для сущности](luis-concept-data-extraction.md#hierarchical-entity-data)|

<a name="prebuilt"></a>
**Предварительно созданные** сущности — это настраиваемые сущности, предоставляемые службой LUIS. Некоторые из этих сущностей определены в проекте [Recognizers-Text](https://github.com/Microsoft/Recognizers-Text) с открытым исходным кодом. В каталоге /Specs приводится много [примеров](https://github.com/Microsoft/Recognizers-Text/tree/master/Specs) для поддерживаемых языков и региональных параметров. Если в настоящее время определенный язык и региональные параметры или сущность не поддерживается, примите участие в добавлении материалов в проект. 

<a name="machine-learned"></a>
**Прошедшие машинное обучение** сущности лучше всего работают после тестирования с помощью [запросов конечной точки](luis-concept-test.md#endpoint-testing) и [проверки высказываний конечной точки](luis-how-to-review-endoint-utt.md). 

<a name="regex"></a>
**Сущности регулярных выражений** определяются регулярным выражением, предоставляемым пользователем в виде части определения сущности. 

Сущности с <a name="exact-match"></a>
**точным совпадением** используют приведенный в сущности текст для получения точного текстового совпадения.

<a name="mixed"></a>
**Смешанные** сущности используют сочетание методов обнаружения сущности.

## <a name="entity-limits"></a>Ограничения сущностей
Ознакомьтесь с [ограничениями](luis-boundaries.md#model-boundaries), чтобы понять, сколько сущностей каждого типа можно добавить в модель.

## <a name="entity-roles"></a>Роли сущности
[Роли](luis-concept-roles.md) сущности используются только в шаблонах. 

## <a name="composite-vs-hierarchical-entities"></a>Сравнение составных и иерархических сущностей
Составные и иерархические сущности имеют связь "родитель-потомок" и прошли машинное обучение. Благодаря машинному обучению LUIS может понимать сущности на основе различных контекстов (расположения слов). Составные сущности более гибкие, так как в качестве дочерних они поддерживают различные типы сущностей. Дочерними элементами иерархической сущности являются только простые сущности. 

|type|Назначение|Пример|
|--|--|--|
|Иерархическая сущность|Родительские и дочерние сущности простых сущностей|Location.Origin=New York<br>Location.Destination=London|
|Составная сущность|Родительские и дочерние сущности: предварительно созданные, списка, простые, иерархические| number=3<br>list=first class<br>prebuilt.datetimeV2=March 5|

## <a name="data-matching-multiple-entities"></a>Данные, соответствующие нескольким сущностям
Если слово или фраза соответствует нескольким сущностям, запрос конечной точки возвращает каждую сущность. Если вы добавили предварительно созданную сущность number и предварительную сущность datetimeV2 и у вас есть высказывание `create meeting on 2018/03/12 for lunch with wayne`, LUIS распознает все сущности и возвратит массив сущностей в составе ответа JSON конечной точки: 

```JSON
{
  "query": "create meeting on 2018/03/12 for lunch with wayne",
  "topScoringIntent": {
    "intent": "Calendar.Add",
    "score": 0.9333419
  },
  "entities": [
    {
      "entity": "2018/03/12",
      "type": "builtin.datetimeV2.date",
      "startIndex": 18,
      "endIndex": 27,
      "resolution": {
        "values": [
          {
            "timex": "2018-03-12",
            "type": "date",
            "value": "2018-03-12"
          }
        ]
      }
    },
    {
      "entity": "2018",
      "type": "builtin.number",
      "startIndex": 18,
      "endIndex": 21,
      "resolution": {
        "value": "2018"
      }
    },
    {
      "entity": "03/12",
      "type": "builtin.number",
      "startIndex": 23,
      "endIndex": 27,
      "resolution": {
        "value": "0.25"
      }
    }
  ]
}
```

## <a name="data-matching-multiple-list-entities"></a>Данные, соответствующие нескольким сущностям списка
Если слово или фраза соответствует нескольким сущностям списка, запрос конечной точки возвращает каждую сущность списка.

Если имеется запрос `when is the best time to go to red rock?` и слово `red` приложения находится в нескольких списках, LUIS распознает все сущности и возвратит массив сущностей в составе ответа JSON конечной точки: 

```JSON
{
  "query": "when is the best time to go to red rock?",
  "topScoringIntent": {
    "intent": "Calendar.Find",
    "score": 0.06701678
  },
  "entities": [
    {
      "entity": "red",
      "type": "Colors",
      "startIndex": 31,
      "endIndex": 33,
      "resolution": {
        "values": [
          "Red"
        ]
      }
    },
    {
      "entity": "red rock",
      "type": "Cities",
      "startIndex": 31,
      "endIndex": 38,
      "resolution": {
        "values": [
          "Destinations"
        ]
      }
    }
  ]
}
```

## <a name="if-you-need-more-than-the-maximum-number-of-entities"></a>Если требуется количество сущностей, превышающее максимальное значение 

Может потребоваться использовать иерархические и составные сущности. Иерархические сущности отражают связь между сущностями, имеющими общие характеристики или являющимися членами категории. Все дочерние сущности входят в их родительскую категорию. Например, у иерархической сущности PlaneTicketClass могут быть дочерние сущности EconomyClass и FirstClass. Иерархия распространяется только на один уровень глубины.  

Составные сущности представляют части целого. Например, у составной сущности PlaneTicketOrder могут быть дочерние сущности Airline, Destination, DepartureCity, DepartureDate и PlaneTicketClass. Составная сущность создается на основе существующих простых сущностей, дочерних элементов иерархических сущностей или предварительно созданных сущностей.  

LUIS также предоставляет тип сущности списка, который не прошел машинное обучение, но позволяет приложению LUIS указывать фиксированный список значений. Ограничения для типа сущности списка см. в статье [Границы LUIS](luis-boundaries.md). 

Если вы рассматривали иерархические, составные сущности и сущности списка, но вам требуются значения, превышавшие ограничения, обратитесь в службу поддержки. Для этого соберите подробные сведения о системе, откройте веб-сайт [LUIS](luis-reference-regions.md#luis-website), а затем выберите элемент **Поддержка**. Если ваша подписка Azure включает службы поддержки, обратитесь в службу [технической поддержки Azure](https://azure.microsoft.com/support/options/). 

## <a name="best-practices"></a>Рекомендации

Создавайте [сущность](luis-concept-entity-types.md), когда вызывающему приложению или боту требуются некоторые параметры или данные из выражения, необходимые для выполнения действия. Сущность — это слово или фраза в высказывании, которые требуется извлечь, возможно, в качестве параметра для функции. 

Чтобы выбрать правильный тип сущности для добавления в приложение, необходимо знать, что эти данные введены пользователями. Каждый тип сущности определяется с помощью разного механизма, например машинного обучения, закрытого списка или регулярного выражения. Если вы не знаете, какую сущность использовать, начните с простой сущности и пометьте слово или фразу, представляющую данные, во всех высказываниях и всех намерениях, включая намерение None.  

Регулярно просматривайте высказывания конечной точки, чтобы определить варианты общего использования, где сущность может быть определена как регулярное выражение или найдена при точном текстовом совпадении.  

В ходе проверки рекомендуется добавить список фраз, чтобы добавить в LUIS сигнал для слов или фраз, имеющих большое значение для предметной области, но не являющихся точными совпадениями, и в которых служба LUIS не уверена полностью.  

Дополнительные сведения см. в статье с [рекомендациями](luis-concept-best-practices.md).

## <a name="next-steps"></a>Дополнительная информация

Ознакомьтесь с подходящими [высказываниями](luis-concept-utterance.md). 

Дополнительные сведения о добавлении сущностей в приложение LUIS см. в статье [Добавление сущностей](luis-how-to-add-entities.md).