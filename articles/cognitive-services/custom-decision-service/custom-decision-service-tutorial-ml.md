---
title: Машинное обучение в Azure Cognitive Services | Документация Майкрософт
description: Руководство по машинному обучению в Пользовательской службе принятия решений Azure (облачного API для контекстного принятия решений).
services: cognitive-services
author: slivkins
manager: slivkins
ms.service: cognitive-services
ms.topic: article
ms.date: 05/08/2018
ms.author: slivkins;marcozo;alekh
ms.openlocfilehash: 50814d67ee39c6657954610358462d877843416e
ms.sourcegitcommit: 95d9a6acf29405a533db943b1688612980374272
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2018
ms.locfileid: "35382156"
---
# <a name="machine-learning"></a>Машинное обучение

В этом руководстве описаны дополнительные функциональные возможности машинного обучения в Пользовательской службе принятия решений. Это руководство состоит из двух частей: [добавление функциональных средств](#featurization-concepts-and-implementation) и [определение компонентов](#feature-specification-format-and-apis). Раздел о добавлении функциональных средств описывает предоставление данных как "компонентов" для машинного обучения. Раздел определения компонентов содержит данные о формате JSON и вспомогательных API-интерфейсах для указания компонентов.

По умолчанию машинное обучение в Пользовательской службе принятия решений является прозрачным для клиента. Компоненты автоматически извлекаются из содержимого и применяется стандартное усиление обучающего алгоритма. Извлечение компонентов использует несколько других служб Cognitive Services Azure: [связывания сущностей](../entitylinking/home.md), [текстовой аналитики](../text-analytics/overview.md), [распознавания эмоций](../emotion/home.md) и [компьютерного зрения](../computer-vision/home.md). Это руководство можно пропустить, если используются только функциональные возможности по умолчанию.

## <a name="featurization-concepts-and-implementation"></a>Концепции и реализация добавления функциональных средств

Решения в Пользовательской службе принятия решений принимаются по очереди. Каждое решение подразумевает выбор среди нескольких альтернативных вариантов, так называемых, действий. В зависимости от приложения, в решении может использоваться одно действие или (короткий) ранжированный список действий.

Например, персонализация выбранных статей на главной странице веб-сайта. Здесь действия соответствуют статьям и каждое решение обозначает статьи, отображаемые для данного пользователя.

Каждое действие представлено вектором свойств (далее в этой статье — *компоненты*). Вы можете указать новые компоненты в дополнение к автоматически извлеченным компонентам. Вы также можете указать Пользовательской службе принятия решений регистрировать в журналы некоторые компоненты, но игнорировать их для машинного обучения.

### <a name="native-vs-internal-features"></a>Собственные и внутренние компоненты

Вы можете указать компоненты в наиболее собственном формате приложения, будь то число, строка или массив. Эти компоненты называются "собственными". Пользовательская служба принятия решений преобразует каждый собственный компонент в один или несколько числовых компонентов (так называемые "внутренние компоненты").

Преобразование во внутренние компоненты выглядит следующим образом.

- Числовые компоненты остаются прежними.
- Числовой массив преобразуется в несколько числовых компонентов, по одному для каждого элемента массива.
- По умолчанию строковой компонент `"Name":"Value"` преобразовывается в компонент с именем `"NameValue"` и значением 1.
- При необходимости строку можно представить как [набор слов](https://en.wikipedia.org/wiki/Bag-of-words_model). Затем для каждого слова в строке создается внутренний компонент, значением которого является количество вхождений этого слова.
- Внутренние компоненты с нулевым значением опущены.

### <a name="shared-vs-action-dependent-features"></a>Общие и зависящие от действий компоненты

Некоторые компоненты касаются всего решения и одинаковы для всех действий. Они называются *общие компоненты*. Некоторые компоненты зависят от конкретного действия. Они называются *компоненты, зависящие от действия* (ADF).

В выполняющемся примере общие компоненты могут описать пользователя или состояние системы. Такие компоненты, как географическое положение, возраст и пол пользователя, а также данные о выполняемых на данный момент основных событий. Компоненты, зависящие от действия, могут описывать свойства статьи (например, темы, рассматриваемые в данной статье).

### <a name="interacting-features"></a>Взаимодействующие компоненты

Компоненты часто "взаимодействуют" (действие одного компонента зависит от других). Например, компонент X обозначает, заинтересован ли пользователь в видах спорта. Компонент Y обозначает, посвящена ли данная статья видам спорта. Затем эффект компонента Y становится сильно зависящим от компонента X.

Чтобы учесть взаимодействие компонентов X и Y, создайте *квадратичный* компонент, значение которого равно X\*Y. (Допускается также применение "пересекающихся" значений X и Y.) Вы можете указать, какие пары компонентов являются перекрестными.

> [!TIP]
> Общие и зависящие от действий компоненты должны пересекаться, чтобы влиять на их ранжирование. Зависящий от действий компонент должен пересекаться с общими компонентами, чтобы способствовать персонализации.

Другими словами, общий компонент, не пересекающийся с любыми ADF, одинаково влияет на каждое действие. ADF, не пересекающийся с любым общим компонентом, также влияет на каждое решение. Компоненты таких типов могут уменьшить расхождение оценок наград.

### <a name="implementation-via-namespaces"></a>Реализация через пространства имен

Вы можете реализовать перекрестные компоненты (а также другие понятия добавления функциональных средств) "командной строки VW" на портале. Синтаксис основан на командной строке [Vowpal Wabbit](http://hunch.net/~vw/).

Центральным элементом реализации является концепция *пространства имен* (именованное подмножество компонентов). Каждый компонент состоит только в одном пространстве имен. Пространство имен можно указать явно, если задано значение компонентов для Пользовательской службы принятия решений. Это единственный способ ознакомиться с компонентом в командной строке VW.

Пространство имен является либо "общим", либо "зависящим от действий". Оно также может содержать только общие или только зависящие от действий компоненты одного действия.

> [!TIP]
> Рекомендуется создавать оболочку для компонентов в явно указанных пространствах имен. Сгруппируйте связанные компоненты в одном пространстве имен.

Если пространство имен не указано, средство автоматически назначается пространству имен по умолчанию.

> [!IMPORTANT]
> Компоненты и пространства имен не обязательно должны быть согласованы в различных действиях. В частности, пространство имен может иметь различные компоненты для разных действий. Кроме того, данное пространство имен можно определить только для конкретных действий.

Несколько внутренних компонентов, полученных из одного собственного строкового компонента, группируются в одном пространстве имен. Любые два собственные компоненты из разных пространств имен рассматриваются как разные, даже если они имеют одинаковые имена.

> [!IMPORTANT]
> Хотя часто используются длинные, описательные идентификаторы пространств имен, командная строка VW не различает пространства имен, идентификатор которых начинается с одинаковой буквы. Далее идентификаторы пространства имен являются одиночными буквами (например, `x` и `y`).

Ниже приведены сведения о реализации.

- Чтобы выполнить пересечение пространств имен `x` и `y`, создайте запись `-q xy` или `--quadratic xy`. После этого все компоненты в `x` пересекаются со всеми компонентами в `y`. Используйте `-q x:`, чтобы выполнить пересечение `x` со всеми пространствами имен, а `-q ::` — со всеми парами пространств имен.

- Чтобы игнорировать все компоненты в пространстве имен `x`, создайте запись `--ignore x`.

Эти команды применяются ко всем действиям отдельно при каждом определении пространств имен.

### <a name="estimated-average-as-a-feature"></a>Предполагаемое среднее значение как компонент

В качестве мысленного эксперимента, предположите, какая средняя награда данного действия, если выбрать его для всех решений? Такие средние награды можно использовать в качестве меры "общего качества" этого действия. Результат, если в некоторых решениях применялись другие действия, неизвестен. Однако это можно оценить с помощью методов закрепления знаний. Качество этой оценки, как правило, улучшается со временем.

Эту "оценочную среднюю награду" можно добавить в качестве компонента для данного действия. Затем Пользовательская служба принятия решений должна автоматически обновить оценку при поступлении новых данных. Этот компонент называется *граничным компонентом* данного действия. Граничные компоненты можно использовать для машинного обучения, а также для аудита.

Чтобы добавить граничные компоненты, создайте запись `--marginal <namespace>` в командной строке VW. Определите `<namespace>` в формате JSON, как показано ниже.

```json
{<namespace>: {"mf_name":1 "action_id":1}
```

Вставьте это пространство имен, а также другие зависимые от действия компоненты, чтобы выполнить это действие. Укажите это определение для каждого решения, используя одинаковые `mf_name` и `action_id` для всех решений.

Граничный компонент добавляется для каждого действия с помощью `<namespace>`. Для `action_id` можно указать любое имя компонента, которое однозначно определяет действие. Имя компонента — `mf_name`. В частности, граничные компоненты с разными `mf_name` рассматриваются как разные компоненты (для каждого `mf_name` предоставляются разные значения веса).

По умолчанию используется одинаковое значение `mf_name` для всех действий. Затем для всех граничных компонентов предоставляется одно значение веса.

Вы можете также указать несколько граничных компонентов для одного действия с одинаковыми значениями и разными именами.

```json
{<namespace>: {"mf_name1":1 "action_id":1 "mf_name2":1 "action_id":1}}
```

### <a name="1-hot-encoding"></a>Кодирование 1-hot

Вы можете предоставлять некоторые функции в виде битовых векторов, где каждый бит соответствует диапазону возможных значений. Этот бит имеет значение 1, только если компонент находится в данном диапазоне. Таким образом, имеется один "высокий" бит со значением 1 и другие биты со значениями 0. Это представление известно как *кодирование 1-hot*.

Кодирование 1-hot обычно используется для категориальных компонентов, таких как "географический регион", у которых по определению отсутствует собственное значимое числовое представление. Это кодирование также рекомендуется для числовых компонентов, влияющих на награды нелинейным образом. Например, данная статья может иметь отношение к определенной возрастной группе и не иметь никакого отношения к старшей или младшей аудитории.

Все строковые компоненты кодируются способом 1-hot по умолчанию. Для каждого возможного значения создается отдельный внутренний компонент. Сейчас недоступны автоматическое кодирование 1-hot для числовых компонентов или кодирование с настроенными диапазонами.

> [!TIP]
> Алгоритмы машинного обучения обрабатывают все возможные значения заданного внутреннего компонента одним способом — через общий "вес". Для кодирования 1-hot позволяется использовать отдельные значения "веса" для каждого диапазона значений. Уменьшение диапазонов приводит к получению лучших наград после сбора достаточного количества данных, но это может инициировать увеличение объема данных, необходимых для получения этих наград.

## <a name="feature-specification-format-and-apis"></a>Спецификация компонента: формат и API-интерфейсы

Вы можете указать компоненты через несколько вспомогательных API-интерфейсов. Все API-интерфейсы используют общий формат JSON. Ниже перечислены API-интерфейсы и формат на концептуальном уровне. Спецификации дополнены схемой Swagger.

Базовый шаблон JSON для спецификации компонента выглядит следующим образом.

```json
{
"<name>":<value>, "<name>":<value>, ... ,
"namespace1": {"<name>":<value>, ... },
"namespace2": {"<name>":<value>, ... },
...
}
```

Где `<name>` и `<value>` обозначают имя и значение компонента соответственно. `<value>` может быть строкой, целым числом, значением float, логическим значением или массивом. Компонент, на заключенный в пространство имен, автоматически назначается пространству имен по умолчанию.

Чтобы представить строку в качестве набора слов, используйте специальный синтаксис `"_text":"string"` вместо `"<name>":<value>`. Фактически отдельный внутренний компонент создается для каждого слова в строке. Его значением является количество вхождений данного слова.

Если `<name>` начинается с "_" (а не с `"_text"`), то компонент не учитывается.

> [!TIP]
> Иногда объединяются компоненты из нескольких источников JSON. Для удобства можно представить их следующим образом:
>
> ```json
> {
> "source1":<features>,
> "source2":<features>,
> ...
> }
> ```

Где `<features>` означает спецификацию основного компонента, определенную ранее. Более глубокие уровни "вложения" также разрешены. Пользовательская служба принятия решений автоматически обнаруживает "самые глубокие" объекты JSON, которые могут интерпретироваться как `<features>`.

#### <a name="feature-set-api"></a>API-интерфейс набора компонентов

API-интерфейс набора компонентов возвращает список функций в формате JSON, описанном выше. Вы можете использовать несколько конечных точек API-интерфейса набора компонентов. Каждая конечная точка определяется идентификатором и URL-адресом набора компонентов. Сопоставление идентификаторов и URL-адресов набора компонентов устанавливается на портале.

Вызовите API-интерфейс набора компонентов, вставив соответствующий идентификатор набора компонентов в соответствующее место в JSON-файле. Для зависимых от действий компонентов вызов автоматически параметризуется с помощью идентификатора действия. Вы можете указать несколько идентификаторов набора компонентов для одного действия.

#### <a name="action-set-api-json-version"></a>API-интерфейс набора действий (версия JSON)

API-интерфейс набора действий имеет версию, в которой указаны действия и компоненты в формате JSON. Компоненты можно задать явным образом или посредством API-интерфейсов набора компонентов. Общие компоненты можно указать один раз для всех действий.

#### <a name="ranking-api-http-post-call"></a>API-интерфейс ранжирования (вызов HTTP POST)

API-интерфейс ранжирования имеет версию, которая использует вызов HTTP POST. В тексте данного вызова указаны действия и компоненты посредством гибкого синтаксиса JSON.

Действия можно задать явным образом или посредством идентификаторов набора действий. При обнаружении идентификатора набора действия выполняется вызов соответствующей конечной точки API-интерфейса набора действий.

Для API-интерфейса набора действий компоненты можно задать явным образом или посредством API-интерфейсов набора компонентов. Общие компоненты можно указать один раз для всех действий.