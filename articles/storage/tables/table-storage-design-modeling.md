---
title: Моделирование отношений в структуре таблиц службы хранилища Azure | Документация Майкрософт
description: Сведения о процессе моделирования при разработке решения хранилища таблиц.
services: storage
documentationcenter: na
author: MarkMcGeeAtAquent
manager: kfile
ms.assetid: 8e228b0c-2998-4462-8101-9f16517393ca
ms.service: storage
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: data-services
ms.date: 04/23/2018
ms.author: sngun
ms.openlocfilehash: 561281375273135009a956fd27dfe9f193ab92ac
ms.sourcegitcommit: 266fe4c2216c0420e415d733cd3abbf94994533d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/01/2018
ms.locfileid: "34660395"
---
# <a name="modeling-relationships"></a>Моделирование отношений
В этой статье рассматривается процесс моделирования при разработке решений хранилища таблиц Azure.

Построение модели предметной области является одним из ключевых этапов при разработке комплексных систем. Как правило, процесс моделирования используется для определения сущностей и отношений между ними. Это позволяет понять направление бизнес-деятельности и представить структуру системы. В этом разделе рассматривается процедура преобразования некоторых распространенных типов отношений, присутствующих в моделях предметной области, в схемы для службы таблиц. Процесс сопоставления логической модели данных с физической моделью данных на базе NoSQL отличается от аналогичного процесса, используемого при проектировании реляционной базы данных. При разработке реляционных баз данных обычно предполагается наличие таких компонентов, как оптимизированный процесс нормализации данных для сведения к минимуму избыточности и возможность выполнения декларативных запросов, которая абстрагирует процесс реализации базы данных.  

## <a name="one-to-many-relationships"></a>Отношения «один-ко-многим»
Отношения "один-ко-многим" между бизнес-объектами являются распространенными. Например, в одном отделе работает много сотрудников. Существует несколько способов реализации отношений «один-ко-многим» в службе таблиц, каждый со своими преимуществами и недостатками, которые могут иметь определенное значение в конкретном сценарии.  

Рассмотрим пример с крупной международной компанией, имеющей десятки тысяч сущностей отделов и сотрудников, где в каждом отделе работает множество сотрудников, каждый из которых, в свою очередь, связан с одним конкретным отделом. Первый подход заключается в хранении отдельных сущностей отделов и сотрудников, как показано ниже.  


![Хранение отдельных сущностей отделов и сотрудников](media/storage-table-design-guide/storage-table-design-IMAGE01.png)

В этом примере демонстрируется явное отношение «один-ко-многим» между типами на основе значения **PartitionKey** . В каждом отделе может работать много сотрудников.  

В этом примере также показана сущность отдела и связанные сущности сотрудников в одном разделе. Для разных типов сущностей можно выбрать использование разных разделов, таблиц или даже учетных записей хранилища.  

В качестве альтернативного подхода выступает денормализация данных и хранение только сущностей сотрудников с денормализованными данными отдела, как показано в следующем примере. В данном случае денормализованный подход может оказаться не лучшим вариантом, если присутствуют требования к возможности изменения сведений о руководителе отдела, поскольку для этого придется обновлять каждого сотрудника отдела.  

![Сущность сотрудника](media/storage-table-design-guide/storage-table-design-IMAGE02.png)

Дополнительные сведения см. в разделе [Шаблон денормализации](table-storage-design-patterns.md#denormalization-pattern).  

В следующей таблице приводятся преимущества и недостатки каждого из описанных выше подходов для хранения сущностей сотрудников и отделов, связанных отношением «один-ко-многим». Следует также учитывать планируемую частоту выполнения различных операций. В некоторых случаях допускается использование схемы с ресурсоемкой операцией, если только эта операция выполняется редко.  

<table>
<tr>
<th>Подход</th>
<th>Преимущества</th>
<th>Недостатки</th>
</tr>
<tr>
<td>Отдельные типы сущностей, один раздел, одна таблица</td>
<td>
<ul>
<li>Сущность отдела можно обновить с помощью одной операции.</li>
<li>Если требуется изменять сущность отдела при каждом обновлении, вставке или удалении сущности сотрудника, в целях обеспечения согласованности можно использовать транзакции группы сущностей. Например, в случае поддержки осведомленности о количестве сотрудников в каждом отделе.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий на стороне клиента может потребоваться получить сущность как сотрудника, так и отдела.</li>
<li>Операции хранения выполняются в одном разделе. При значительных объемах транзакций это может привести к формированию активной области.</li>
<li>Транзакции группы сущностей нельзя использовать для перемещения сотрудника в другой отдел.</li>
</ul>
</td>
</tr>
<tr>
<td>Отдельные типы сущностей, разные разделы или таблицы, или учетные записи хранилища</td>
<td>
<ul>
<li>Сущность отдела или сущность сотрудника можно обновить с помощью одной операции.</li>
<li>При значительных объемах транзакций это может помочь распределить нагрузку по нескольким разделам.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий на стороне клиента может потребоваться получить сущность как сотрудника, так и отдела.</li>
<li>Транзакции группы сущностей нельзя использовать для обеспечения согласованности при обновлении, вставке или удалении сотрудника или обновлении отдела. Например, для обновления количества сотрудников в сущности отдела.</li>
<li>Транзакции группы сущностей нельзя использовать для перемещения сотрудника в другой отдел.</li>
</ul>
</td>
</tr>
<tr>
<td>Денормализация в один тип сущности</td>
<td>
<ul>
<li>Все необходимые данные можно извлечь с помощью одного запроса.</li>
</ul>
</td>
<td>
<ul>
<li>Если требуется обновить сведения об отделе (будет необходимо обновить всех сотрудников в отделе), обеспечение согласованности может оказаться ресурсоемким процессом.</li>
</ul>
</td>
</tr>
</table>

Выбор подходящего варианта и определение наиболее значимых преимуществ и недостатков зависит от конкретных сценариев в приложении. Например, как часто выполняется изменение сущностей отдела? Всем ли запросам к сотрудникам требуются дополнительные сведения об отделе? Насколько близко вы подошли к показателям ограничения масштабируемости в разделах или учетной записи хранения?  

## <a name="one-to-one-relationships"></a>Отношения «один-к-одному»
В модель предметной области могут входить отношения между сущностями «один-к-одному». Чтобы реализовать отношение «один-к-одному» в службе таблиц, необходимо выбрать способ привязки двух связанных сущностей, если потребуется извлечь их обе. Эта связь может быть либо неявной (на основе соглашения в значениях ключа), либо явной с сохранением связи в форме значений **PartitionKey** и **RowKey** в каждой сущности. Сведения о необходимости хранения связанных сущностей в одном разделе см. в разделе [Отношения "один-ко-многим"](#one-to-many-relationships).  

Есть также ряд аспектов, которые могут привести к реализации отношений "один-к-одному" в службе таблиц.  

* Обработка сущностей большого размера (дополнительные сведения см. в статье [Шаблон для сущностей больших размеров](table-storage-design-patterns.md#large-entities-pattern)).  
* Внедрение средств управления доступом (см. раздел [Управление доступом с помощью подписанных URL-адресов](#controlling-access-with-shared-access-signatures)).  

## <a name="join-in-the-client"></a>Присоединение клиента
Несмотря на то, что в службе таблиц существуют возможности моделирования, не следует забывать две основные причины использования службы таблиц — масштабируемость и производительность. Если вы считаете, что моделируете много отношений, которые приводят к ухудшению производительности и масштабируемости решения, стоит подумать о необходимости ввода всех взаимосвязей между данными в структуру таблицы. Необходимые операции присоединения, выполненные клиентским приложением, позволят упростить структуру и улучшить масштабируемость и производительность решения.  

Например, данные, которые содержатся в небольших таблицах и меняются не часто, можно извлекать по мере необходимости и кэшировать на стороне клиента. Это позволит избежать повторяющихся циклические операций по извлечению одних и тех же данных. В примерах, рассмотренных в данном руководстве, количество отделов в небольшой организации, вероятно, будет невысоким с нечастыми изменениями. В таком случае оптимален вариант, когда клиентское приложение один раз загружает данные и кэширует их.  

## <a name="inheritance-relationships"></a>Отношения наследования
Если клиентское приложение использует набор классов, которые являются частью наследственной связи для представления бизнес-сущностей, эти сущности можно сохранить в службе таблиц. Например, в клиентском приложении может быть определен следующий набор классов, где класс **Person** является абстрактным.

![Абстрактный класс Person](media/storage-table-design-guide/storage-table-design-IMAGE03.png)

Экземпляры двух конкретных классов можно сохранить в службе таблиц с помощью одной таблицы Person с сущностями, которые выглядят следующим образом.  

![Таблица Person](media/storage-table-design-guide/storage-table-design-IMAGE04.png)

Дополнительные сведения о работе с несколькими типами сущностей в одной таблице в клиентском коде см. в разделе [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types) далее в этом руководстве. Там приводятся примеры определения типа сущности в клиентском коде.  


## <a name="next-steps"></a>Дополнительная информация

- [Шаблоны для разработки таблиц](table-storage-design-patterns.md)
- [Разработка для запросов](table-storage-design-for-query.md)
- [Шифрование данных таблиц](table-storage-design-encrypt-data.md)
- [Разработка для изменения данных](table-storage-design-for-modification.md)